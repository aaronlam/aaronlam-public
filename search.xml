<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何修改Git Commit的描述</title>
    <url>/2018/10/30/amend-git-committed-comment/</url>
    <content><![CDATA[<p>使用 Git 进行项目的版本管理，的确是能让项目代码更加的受控。但是如果能有清晰的 commit 记录以及描述，那将更是会锦上添花。在需求正常开发完后，有时难免会过于兴奋手滑敲错 commit 的描述。但如果对于不经常手滑的同学来说，可能还没研究过如何修改 commit 的描述。所以今天，我就想通过这一篇文章简单的记录一下 commit 描述的修改过程，顺便给自己留作回顾的作用。</p>
<p>修改 commit 描述分为以下两种情况，但这两种情况步骤基本相同，只是第二种需要在最后多加一步操作：</p>
<ol>
<li>还未将代码 push 到远程仓库</li>
<li>已将代码 push 到远程仓库</li>
</ol>
<a id="more"></a>

<h1 id="修改最后一次-commit-的描述"><a href="#修改最后一次-commit-的描述" class="headerlink" title="修改最后一次 commit 的描述"></a>修改最后一次 commit 的描述</h1><p>如果只是想修改最后一次 commit 后的描述，可以直接在命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>输入完后，会出现以下界面（commit 的描述位于界面的第一行）：</p>
<ol>
<li>按 <kbd>i</kbd> 键进入命令行的修改模式，修改位于界面第一行的 commit 描述</li>
<li>修改完后，按 <kbd>Esc</kbd> 键退出命令行的编辑模式</li>
<li>再输入 <code>:wq</code> 保存并退出，至此 commit 的描述就修改成功啦！</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201028225408.png" alt="修改最后一次commit的描述"></p>
<h1 id="修改之前某次-commit-的描述"><a href="#修改之前某次-commit-的描述" class="headerlink" title="修改之前某次 commit 的描述"></a>修改之前某次 commit 的描述</h1><p>如果是想修改之前某次 commit 的描述，则需要比修改最后一次 commit 的描述多上那么几个步骤。其实这个修改的原理，按我的理解就是先把版本回退到你想修改的某个版本，然后再修改当前回退到的版本的 commit 描述，修改完后再回到回退前的最新版本中。那么来吧！</p>
<p>首先在命令行输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令中最后的数字2指的是显示倒数第几次的commit，比如我这里的2就代表显示倒数第二次的commit描述</span></span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>

<p>输入完后，会出现以下界面（倒数几次的 commit 的描述都位于界面顶部）：</p>
<ol>
<li>想修改哪条 commit 的描述，就把该条 commit 描述前的 <strong>pick</strong> 改成 <strong>edit</strong>（修改的方式同上）</li>
<li>修改完后按 <kbd>Esc</kbd> 键退出命令行的编辑模式，</li>
<li>输入 <code>:wq</code> 保存并退出。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201028233014.png" alt="修改之前某次commit的描述1"></p>
<p>保存并退出后，会出现以下界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201028234716.png" alt="修改之前某次commit的描述2"></p>
<p>然后，再往命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>输入完后，就如同上面那样修改完描述，然后保存并退出后，再往命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<h1 id="修改之前的某几次-commit-的描述"><a href="#修改之前的某几次-commit-的描述" class="headerlink" title="修改之前的某几次 commit 的描述"></a>修改之前的某几次 commit 的描述</h1><p>修改之前某几次其实和上面修改某次的步骤差不多，不同之处在于以下几点：</p>
<ol>
<li>上面，第一个步骤中的命令，数字需要修改</li>
<li>然后在修改 <strong>pick</strong> 为 <strong>edit</strong> 的那一个步骤时，修改多个</li>
<li>最后依次修改描述（顺序是从旧到新），命令行中基本都会提示你接下来的操作是什么，每次修改一个注释都需要重复上面的最后两个步骤，直至修改完你所标记为 <strong>edit</strong> 的所有描述为止</li>
</ol>
<h1 id="已经将代码-push-到远程仓库"><a href="#已经将代码-push-到远程仓库" class="headerlink" title="已经将代码 push 到远程仓库"></a>已经将代码 push 到远程仓库</h1><p>在已经把代码 push 到远程仓库的情况下，还想修改 commit 的描述的话，在修改前首先需要从远程仓库 pull 最新的版本到本地仓库，确保两边的版本都是一致的状态。然后再按照情况，选择上面的几种方法来进行修改。最后，修改完需要再强制把本地仓库的版本 push 回远程仓库中。<strong>但很重要的一点是，在进行强制 push 之前，需要再三确认没有人往远程仓库提交更新的版本，否则远程仓库中更新的版本将会被你的版本所覆盖。</strong></p>
<p>在命令行中输入以下命令，强制 push 本地仓库版本到远程仓库中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<p>大功告成！</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建公司内部的npm私服</title>
    <url>/2019/01/01/build-private-npm-proxy/</url>
    <content><![CDATA[<p>由于我们公司内部的前端项目越来越多并且迭代速度越来越快，项目里的业务系统也精细的进行了不同的划分，那么这些项目之间的公共代码以及公共组件的提取、维护、管理问题就也愈显的突出。所以，最近都在进行公共库的维护以及公共组件的提取工作，然后再把这些公共库和公共组件库以依赖包的形式进行管理，同样的我们使用了 SemVer 来进行版本号的规范化，最后再以依赖包的形式进行发布。这就让我们可以把这些单独“拎出来的代码”能够以 <code>npm install</code> 或 <code>yarn add</code> 的形式来进行依赖包安装，然后再引入到实际用到的每个项目里，这样一旦这些公共库或公共组件库更新了，就不用在每个项目里一份一份的复制粘贴了，直接 <code>npm update</code> 或 <code>yarn upgrade</code> 了事。</p>
<p>但是，对于一些公共库的代码可能会涉及到比较核心的业务逻辑，就导致我们没办法把这些库代码的依赖包以 npm 包的形式发布到公网的 npm 仓库；同时，由于每次前端项目进行依赖包安装时，其安装的速度都依赖于网络以及第三方镜像。所以，这就迫切的需要有一个公司内部的 npm 私有仓库了，也就是 npm 私服。在我研究了目前 npm 私服的几乎所有搭建方式后，总结下来总共有以下几种：</p>
<p>付费：</p>
<ol>
<li><a href="https://www.myget.org/">MyGet</a>：9 刀每月，两个账号，1GB 空间</li>
<li><a href="https://www.npmjs.com/">NPM Org</a>：每个账号每月 7 刀</li>
</ol>
<p>免费：</p>
<ol>
<li><a href="https://docs.npmjs.com/misc/registry">DIY NPM</a></li>
<li><a href="https://github.com/cnpm/cnpmjs.org">CNPM</a></li>
<li><a href="https://www.sonatype.com/">Nexus</a></li>
<li><a href="https://www.npmjs.com/package/sinopia">Sinopia</a></li>
<li><a href="https://verdaccio.org/">Verdaccio</a></li>
</ol>
<p>首先排除付费，根据搭建方式和易用程度来选本来是选择 Sinopia 的，因为其搭建十分简单友好，基本就是傻瓜式的。不过到其 GitHub Repo 页面看到貌似已经放弃维护很多年了，然后再深入调查发现有一群人出了个分支，而这个分支就是 Verdaccio。然后还发现 Verdaccio 延续了 Sinopia 的简单便捷，并且这个库也在积极维护中，看起来就比 Sinopia 靠谱一点。最后就果断的选择了 Verdaccio 来搭建公司内部的 npm 私服。</p>
<p>不过如果公司内部有 Java 技术栈团队的可以尝试一下 Nexus，因为看到他貌似也可以进行 maven/gralde 仓库的统一管理。而我们公司虽然也有 Java 技术栈的团队，但是由于我们部门后端是 .Net 技术栈，遂放弃！</p>
<a id="more"></a>

<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><p>在搭建时我是向公司的运维同学申请了一台内存 4GB 的 Linux 虚拟机，这个配置的话在后续的使用中也没有出现过太大的问题。所以，大家可以根据实际情况来挑选合适的配置进行搭建。但下面的演示步骤，我拿的是 Windows 开发机进行演示的。无须担心，他们的搭建步骤基本是一致的。</p>
<h3 id="1-安装-Node-js"><a href="#1-安装-Node-js" class="headerlink" title="1. 安装 Node.js"></a>1. 安装 Node.js</h3><p>由于我的电脑已经安装上了，所以这里就不再演示了。</p>
<h3 id="2-安装-Verdaccio-依赖包"><a href="#2-安装-Verdaccio-依赖包" class="headerlink" title="2. 安装 Verdaccio 依赖包"></a>2. 安装 Verdaccio 依赖包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g verdaccio</span><br></pre></td></tr></table></figure>

<p>如果安装过程报了 grywarn 的权限错误的话，那么需要加上 <code>--unsafe-perm</code>，如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g verdaccio --unsafe-perm</span><br></pre></td></tr></table></figure>

<h3 id="3-启动-Verdaccio"><a href="#3-启动-Verdaccio" class="headerlink" title="3. 启动 Verdaccio"></a>3. 启动 Verdaccio</h3><p>安装完依赖包后，我们就可以在命令行中输入 <code>verdaccio</code> 命令启动，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210145307.png" alt="启动Verdaccio"></p>
<p>此时，我们在浏览器中，输入 <code>http://localhost:4873</code> 就可以看到用 Verdaccio 搭建好的 npm 私服了，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210145522.png" alt="Verdaccio首页"></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-安装-nrm-yrm"><a href="#1-安装-nrm-yrm" class="headerlink" title="1. 安装 nrm/yrm"></a>1. 安装 nrm/yrm</h3><p>在使用 Verdaccio 所搭建的 npm 私服之前，我们可以先安装 <code>nrm</code> 或者 <code>yrm</code> 来管理自己的 npm 源，这两个命令行工具可以帮助我们快速的修改、切换、增加源。由于 <code>nrm</code> 和 <code>yrm</code> 的使用方式是类似的，所以下面都以 <code>nrm</code> 作为演示的例子。</p>
<p>执行下面的命令安装其依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g nrm</span><br></pre></td></tr></table></figure>

<p>如果想了解更多关于 <code>nrm</code> 的命令，可以执行命令 <code>nrm --help</code> 来查看所列出的所有命令。</p>
<h3 id="2-使用-nrm-添加私服源"><a href="#2-使用-nrm-添加私服源" class="headerlink" title="2. 使用 nrm 添加私服源"></a>2. 使用 nrm 添加私服源</h3><p>我们刚刚已经启动了 Verdaccio，也就表明我们使用 Verdaccio 所搭建的 npm 私服源正在悄悄运行中了。此时，如果我们想要使用他的话就可以用 <code>nrm</code> 来添加该私服源。当然不使用 <code>nrm</code> ，手动使用命令 <code>npm config set registry http://127.0.0.1:4873</code> 去设置 npm 的源地址，或者在项目根目录下创建 <code>.npmrc</code> 配置文件来配置项目使用的源地址也是可以的，不过为了便捷性我们还是使用 <code>nrm</code> 吧。</p>
<p>执行下面的命令添加 npm 私服源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里的verdaccio是名字，可以输入任意名字</span></span><br><span class="line">nrm add verdaccio http://127.0.0.1:4873</span><br></pre></td></tr></table></figure>

<p>添加完后，此时我们就可以执行以下命令，列出目前所有的源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure>

<p>下图中所列出的就是 <code>nrm</code> 中我们所有能够切换的 npm 源了，刚添加的私服源在最下面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210152437.png" alt="所有npm源"></p>
<h3 id="3-利用-nrm-使用私服源"><a href="#3-利用-nrm-使用私服源" class="headerlink" title="3. 利用 nrm 使用私服源"></a>3. 利用 nrm 使用私服源</h3><p>上面我们已经列出了所有能切换的 npm 源了，列表中也出现了我们所添加的私服源。</p>
<p>执行下面的命令把当前 npm 的源切换到私服源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nrm use verdaccio</span><br></pre></td></tr></table></figure>

<p>如下图所示，我们就已经切换到刚添加的私服源了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210153024.png" alt="切换私服源"></p>
<h3 id="4-创建私服源账号"><a href="#4-创建私服源账号" class="headerlink" title="4. 创建私服源账号"></a>4. 创建私服源账号</h3><p>有发布过 npm 包的同学应该知道，在发布前我们都需要先注册 npm 官方源的账号，这样我们才能够把我们开发的 npm 包发布到对应的账号下供别人使用。而我们的私服源也是同样道理，如果要发布包到私服里，也是需要先创建一个私服的账号。我们刚刚已经使用 <code>nrm</code> 把 npm 的源切换到了 verdaccio （私服）源下，那么如何创建账号？往下看！</p>
<p>执行以下命令后就可以根据提示创建账号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure>

<p>如下图所示，我在自己搭建的私服源中创建了 test 账号：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210154239.png" alt="创建私服源账号"></p>
<h3 id="5-登录私服源账号"><a href="#5-登录私服源账号" class="headerlink" title="5. 登录私服源账号"></a>5. 登录私服源账号</h3><p>既然账号都已经创建了，自然就可以使用刚刚的账号登录到所搭建的私服源中。</p>
<p>执行以下命令登录私服源账号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure>

<p>如下图所示，如我们的预期一样，所注册的账号已经可以登录到私服源了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210154239.png" alt="登录私服源账号"></p>
<h3 id="6-发布包到私服源"><a href="#6-发布包到私服源" class="headerlink" title="6. 发布包到私服源"></a>6. 发布包到私服源</h3><p>现在，我们可以尝试一下创建一个项目然后把该项目发布到私服源中。我这里是随便创建了一个文件夹 <code>verdaccio-npm-publish-demo</code>，然后用 VSCode 打开后在终端执行 <code>npm init</code> 初始化项目，再创建一个 <code>index.js</code> 文件，内容就为 <code>console.log(&#39;publish demo&#39;)</code>，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210160045.png" alt="项目概览图"></p>
<p>此时，我们回到在终端中，执行命令 <code>npm login</code> 登录到私服源中，然后再执行命令 <code>npm publish</code> 来把包发布到私服源里去。此时终端就会显示包已经发布成功，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210164544.png" alt="私服源包发布"></p>
<p>我们访问私服源的首页，也会看到我们刚刚所发布的包，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210164312.png" alt="已发布的包"></p>
<h3 id="7-安装私服源里的包"><a href="#7-安装私服源里的包" class="headerlink" title="7. 安装私服源里的包"></a>7. 安装私服源里的包</h3><p>我们已经把项目 <code>verdaccio-npm-publish-demo</code> 以包的形式发布到私服源里了，那么自然的就能够在其他项目里安装这个包。<strong>我们可以像平常安装包依赖一样安装这个包，前提是我们已经把 npm 的源切换到了私服源。</strong>我这里创建了多一个项目 <code>verdaccio-npm-install-demo</code> 来演示安装私服源里的依赖包。</p>
<p>如下图所示，项目 <code>verdaccio-npm-install-demo</code> 里安装了私服源里的 <code>verdaccio-npm-publish-demo</code> 依赖包：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201210165808.png" alt="私服源依赖包安装"></p>
<h2 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h2><p>从上面启动 Verdaccio 的信息来看，他的配置文件应该是 <code>C:\Users\Administrator\AppData\Roaming\verdaccio\</code> 文件夹下的 <code>config.yaml</code> 文件，所以，我们接下来都会在该配置文件中做进一步的配置。</p>
<h3 id="1-外网访问"><a href="#1-外网访问" class="headerlink" title="1. 外网访问"></a>1. 外网访问</h3><p>如果外网也需要访问该 npm 私服的话，那么需要在配置文件的底部增加以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">listen:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:4873</span></span><br></pre></td></tr></table></figure>

<h3 id="2-用户控制"><a href="#2-用户控制" class="headerlink" title="2. 用户控制"></a>2. 用户控制</h3><p>在上文中可以看到 Verdaccio 默认是允许任何人创建账号的，如果没有进一步的配置，那么所创建账号的账号都会有 publish 的权限。所以，如果我们要把控好权限，就要进一步的配置他。</p>
<p>此时，我们打开配置文件，进行以下修改：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: ./htpasswd</span><br><span class="line"><span class="addition">+   max_users: -1</span></span><br><span class="line">    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.</span><br><span class="line">    # You can set this to -1 to disable registration.</span><br><span class="line">    # max_users: 1000</span><br></pre></td></tr></table></figure>

<p>问题来了，如果设置为了 <code>max_users: -1</code>，那以后要怎么增加用户呢？有以下两种方式：</p>
<ol>
<li>手动编辑 <code>htpasswd</code> 文件</li>
<li>使用第三方工具，以 命令的形式增加用户</li>
</ol>
<p>执行以下命令安装 sinopia-adduser（没错，由于 Verdaccio 是由 Sinopia 所分支出来的，所以工具也通用）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i g sinopia-adduser</span><br></pre></td></tr></table></figure>

<p>安装好后，到 <code>htpasswd</code> 文件目录下，运行一下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinopia-adduser</span><br></pre></td></tr></table></figure>

<h3 id="3-权限控制"><a href="#3-权限控制" class="headerlink" title="3. 权限控制"></a>3. 权限控制</h3><p>既然用户已经控制住了，权限当然也要进行控制。我们可以在 Verdaccio 的配置文件中，发现 <code>packages</code> 的配置项，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">packages:</span></span><br><span class="line">  <span class="string">&quot;@*/*&quot;</span><span class="string">:</span></span><br><span class="line">    <span class="comment"># scoped packages</span></span><br><span class="line">    <span class="attr">access:</span> <span class="string">$all</span></span><br><span class="line">    <span class="attr">publish:</span> <span class="string">$authenticated</span></span><br><span class="line">    <span class="attr">unpublish:</span> <span class="string">$authenticated</span></span><br><span class="line">    <span class="attr">proxy:</span> <span class="string">npmjs</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;**&quot;</span><span class="string">:</span></span><br><span class="line">    <span class="comment"># allow all users (including non-authenticated users) to read and</span></span><br><span class="line">    <span class="comment"># publish all packages</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># you can specify usernames/groupnames (depending on your auth plugin)</span></span><br><span class="line">    <span class="comment"># and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span></span><br><span class="line">    <span class="attr">access:</span> <span class="string">$all</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># allow all known users to publish/publish packages</span></span><br><span class="line">    <span class="comment"># (anyone can register by default, remember?)</span></span><br><span class="line">    <span class="attr">publish:</span> <span class="string">$authenticated</span></span><br><span class="line">    <span class="attr">unpublish:</span> <span class="string">$authenticated</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span></span><br><span class="line">    <span class="attr">proxy:</span> <span class="string">npmjs</span></span><br></pre></td></tr></table></figure>

<p>下面简单的介绍一下以上的一些配置项含义：</p>
<p>首先，上面对于 <code>packages</code> 配置项的子配置项有两个，一个是 <code>@*/*</code> 另外一个是 <code>**</code>，而这两个配置项有个名称叫 <code>scope</code>，其作用是用来匹配依赖包名字的。那这样就不难发现 <code>@*/*</code> 应该就是用来匹配类似 <code>@babel/preset-env</code> 这种依赖包的，而 <code>**</code> 就是用来匹配 <code>webpack</code> 这种依赖包的。这样的话，我们就可以针对依赖包的名字做以下的详细配置。</p>
<p>权限：</p>
<ul>
<li><code>access</code> 表示哪一类用户可以安装此类依赖包（install）</li>
<li><code>publish</code> 表示哪一类用户可以发布此类依赖包（publish）</li>
<li><code>proxy</code> 这里的值对应的是配置文件中的 <code>uplinks</code> 配置项里的子项名称，<code>uplinks</code> 配置项是配置上游 npm 源的。而 <code>proxy</code> 配置项的作用是如果私服源不存在依赖包，那就去对应配置的上游 npm 源获取。</li>
</ul>
<p>值得含义：</p>
<ul>
<li><code>$all</code> 表示所有人（已注册，未注册）都可以执行对应操作</li>
<li><code>$authenticated</code> 表示只有注册且登录的用户才可以执行对应操作</li>
<li><code>$anonymous</code> 表示只有未注册登录可以执行对应操作</li>
</ul>
<p>那就是说，如果我们需要指定某个用户才有权限，就直接配置上其账号名称即可（多个用户用空格隔开），比如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">access:</span> <span class="string">aaronlam</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>修改完配置后重启 verdaccio 即可！</p>
<h2 id="进程守护"><a href="#进程守护" class="headerlink" title="进程守护"></a>进程守护</h2><p>如果此时直接在服务器中执行命令 <code>verdaccio</code> 开启 npm 私服的话，那么就没办法保证其进程能够一直安全的运行。万一进程挂了，那就麻烦大了，所以我们需要使用 Node.js 里的进程守护工具 <code>pm2</code> 来对 <code>verdaccio</code> 进程进行托管启动。</p>
<p>执行以下命令安装依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g pm2</span><br></pre></td></tr></table></figure>

<p>安装好后，我们就可以通过以下命令让 <code>pm2</code> 来托管运行我们的 <code>verdaccio</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 start verdaccio</span><br></pre></td></tr></table></figure>

<p>此时，我们可以通过以下命令来查看 <code>verdaccio</code> 的实时日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 show verdaccio</span><br></pre></td></tr></table></figure>

<p>至此，我们对于搭建公司内部的 npm 私服就完成啦！其实 <code>verdaccio</code> 还有其他的一些插件可以搭配使用，这个就让大家自己去探索了。另外，关于 <code>pm2</code> 命令行进程守护工具的更多用法，可以移步到 <a href="https://pm2.keymetrics.io/docs/usage/quick-start/">pm2 官网的文档</a>查看。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS Module和ES6 Modules之间的引用与转换</title>
    <url>/2019/10/05/commonjs-and-es6-modules/</url>
    <content><![CDATA[<p>平时在项目开发的过程中，因为 JavaScript 模块化的历史遗留问题，难免会存在在 CommonJS 的模块里头 <code>import</code> ES6 的模块，或者在 CommonJS 的模块里头 <code>require</code> ES6 的模块的情况发生。为了能够搞清楚他们之间的转换小秘密，所以就专门记录一下，方便日后回顾，顺便上来水一文。</p>
<blockquote>
<p>因为这两种模块在网络上存在着各式各样的叫法，所以在文章开始前，为了能够和大家达成一致的共识。在后面我将会用 <strong>CJS</strong> 代指 CommonJS Module，用 <strong>ESM</strong> 代指 ES Modules。</p>
</blockquote>
<h1 id="ESM-转-CJS"><a href="#ESM-转-CJS" class="headerlink" title="ESM 转 CJS"></a>ESM 转 CJS</h1><h2 id="1-ESM-export-转-CJS-exports"><a href="#1-ESM-export-转-CJS-exports" class="headerlink" title="1. ESM export 转 CJS exports"></a>1. ESM export 转 CJS exports</h2><p>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>a.js</code> 中的 <strong>ESM</strong> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<blockquote>
<p>注：在 ESM 被转为 CJS 时，转译器会在其导出的对象中定义一个值为 <code>true</code> 的私有的变量 <code>__esModule</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.func = func;</span><br><span class="line"><span class="keyword">var</span> foo = (<span class="built_in">exports</span>.foo = <span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">exports</span>.default = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其实也就等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.__esModule = <span class="literal">true</span>; <span class="comment">// 该属性实际上会通过Object.defineProperty API设置为不可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">exports</span>.default = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="2-ESM-import-转-CJS-require"><a href="#2-ESM-import-转-CJS-require" class="headerlink" title="2. ESM import 转 CJS require"></a>2. ESM import 转 CJS require</h2><h3 id="2-1-Default-import"><a href="#2-1-Default-import" class="headerlink" title="2.1 Default import"></a>2.1 Default import</h3><p>还是一个栗子，直接默认导入 <code>a.js</code> 中的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p><code>b.js</code> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> _a2 = _interopRequireDefault(_a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是ESM则直接返回obj，否则返回带有default属性的新对象</span></span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(_a2.default);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Wildcard-import"><a href="#2-2-Wildcard-import" class="headerlink" title="2.2 Wildcard import"></a>2.2 Wildcard import</h3><p>再一个栗子，名字空间导入 <code>a.js</code> 中的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p><code>b.js</code> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> A = _interopRequireWildcard(_a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireWildcard</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ESM直接返回obj</span></span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.__esModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// CJS的话就创建一个新的空对象，并把obj内的所有自有属性都浅复制到新对象中，最后再把obj赋值给新对象的default属性</span></span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">          newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newObj.default = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol>
<li>ESM 的 <code>export</code> 相当于往 CJS 的 <code>exports</code> 上添加属性<ol>
<li><code>export var/let/const/function/class...</code> 会往 <code>exports</code> 上添加同名属性</li>
<li><code>export default</code> 会往 <code>exports</code> 上添加 default 属性</li>
</ol>
</li>
<li>ESM 可以 <strong>default</strong> <code>import</code> 和 <strong>wildcard</strong> <code>import</code> CJS<ol>
<li><strong>default</strong> <code>import</code> CJS 时，会创建一个新的空对象，并把 CJS 的导出对象 <code>exports</code> 赋值到新对象的 default 属性</li>
<li><strong>wildcard</strong> <code>import</code> CJS 时，会创建一个新的空对象，并把 CJS 的导出对象 <code>exports</code> 中的自有属性浅复制到新的空对象中，最后再把导出对象 <code>exports</code> 赋值到新对象的 default 属性</li>
</ol>
</li>
</ol>
<h1 id="ESM-中引用-CJS"><a href="#ESM-中引用-CJS" class="headerlink" title="ESM 中引用 CJS"></a>ESM 中引用 CJS</h1><p>根据上面得出的结论，ESM 中引用 CJS 有两种方式，栗子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  <span class="keyword">default</span>: <span class="string">&quot;myDefault&quot;</span>,</span><br><span class="line">  foo: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// esm.js</span></span><br><span class="line"><span class="keyword">import</span> cjs <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs = (&#123; default: exports &#125;).default;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cjs2 <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs2 = (&#123; ...exports, default: exports &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> cjs3 &#125; <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs3 = (&#123; default: exports &#125;).default</span></span><br></pre></td></tr></table></figure>

<h1 id="CJS-中引用-ESM"><a href="#CJS-中引用-ESM" class="headerlink" title="CJS 中引用 ESM"></a>CJS 中引用 ESM</h1><p>在 CJS 中引用 ESM 相当于直接引用 ESM 转成 CJS 的 <code>module.exports</code>，栗子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">cls</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">var</span> es = <span class="built_in">require</span>(<span class="string">&quot;./es&quot;</span>);</span><br><span class="line"><span class="comment">/* es结构如下：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    foo,</span></span><br><span class="line"><span class="comment">    bar: foo,</span></span><br><span class="line"><span class="comment">    func,</span></span><br><span class="line"><span class="comment">    cls,</span></span><br><span class="line"><span class="comment">    default: 1</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JacaScript</tag>
        <tag>ESModules</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP/前端文件缓存</title>
    <url>/2019/08/01/http-cache/</url>
    <content><![CDATA[<p>缓存在开发人员的眼里并不陌生，它对于程序的性能和效率的提升起到了至关重要的作用。甚至是在 CPU 与内存这种硬件与硬件间的交互，也存在着多级别的缓存用以提升交互间的性能。同样的，在前端要进行性能的优化，减少客户端与服务端的资源请求，提升客户端页面的加载速度，自然也就摆脱不了缓存这个“魔咒”。而前端文件缓存实质上也就是 HTTP 缓存，而 HTTP 缓存经过 HTTP 版本的迭代升级，也存在着几种不同的缓存设置方式。</p>
<a id="more"></a>

<h1 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h1><p>对于 HTTP 来说，总共分为如下两种类型的缓存，<strong>而强缓存优先级高于协商缓存</strong>。也就是说如果客户端已经存在强缓存后，若还未过期，就不会触发协商缓存。而不同版本的 HTTP 协议，设置这两种类型的缓存，所使用的响应和请求头也各不相同。</p>
<h2 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1.强缓存"></a>1.强缓存</h2><p>强缓存中的“强”一字，指的是让浏览器按照服务端所提供的有效时间来缓存资源，所以就那么一点强制的感觉。而服务端一般使用如下两种 HTTP 响应头部属性，来达到让客户端把资源以强缓存的形式存入缓存数据库。</p>
<h3 id="1-Expires"><a href="#1-Expires" class="headerlink" title="1) Expires"></a>1) Expires</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务端响应头部</span><br><span class="line">...</span><br><span class="line">Expires: Wed, 21 Oct 2019 00:00:00 GMT</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>Expires</code> 是服务端用于强缓存的 HTTP 1.0 <strong>响应头属性</strong>，其值为服务端返回的资源到期（有效）时间，既下一次请求该资源时，客户端会到缓存数据库中取出所缓存资源的 <code>Expires</code> 属性值并与此次资源请求的时间做比较，若请求时间小于该值，就直接使用缓存数据库中所缓存的资源。</p>
<h3 id="2-Cache-Control"><a href="#2-Cache-Control" class="headerlink" title="2) Cache-Control"></a>2) Cache-Control</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务端响应头部</span><br><span class="line">...</span><br><span class="line">Cache-Control:public, max-age&#x3D;31536000</span><br><span class="line"># Expires会被忽略</span><br><span class="line">Expires: Wed, 21 Oct 2019 00:00:00 GMT</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上文已经提到 <code>Expires</code> 是 HTTP 1.0 的<strong>响应头属性</strong>，所以目前已逐渐被淘汰。这样 HTTP 1.1 中的 <code>Cache-Control</code> 就顺势就替代了它，<strong>并且 <code>Expires</code> 和 <code>Cache-Control</code> 同时存在时，<code>Cache-Control</code> 的优先级要高于 <code>Expires</code>。</strong><code>Cache-Control</code> 相较于 <code>Expires</code> 具备更多的特性，指定资源有效时间也改为了相对时间并以秒为单位，而其值就包括如下选项：</p>
<ol>
<li>private：仅客户端可以缓存该资源</li>
<li>public：客户端和代理服务器都可以缓存该资源</li>
<li>max-age=xxx：在客户端中缓存的资源将在资源请求发送后的 xxx 秒后失效</li>
<li>s-maxage=xxx：在代理服务器中缓存的资源将在资源请求发送后的 xxx 秒后失效</li>
<li>no-cache：不使用强缓存，需要使用协商缓存</li>
<li>no-store：资源禁止被缓存，需要每次都请求服务端获取资源</li>
<li>immutable：对于同时设置了 max-age 和 immutable 的资源，如果还在有效期内，用户就算点击了刷新也不再请求服务器获取资源（仅在 HTTPS 下有效）</li>
</ol>
<p>当客户端在下一次请求该资源时，客户端会到缓存数据库中取出所缓存资源的 <code>Cache-Control</code> 属性值的 <strong>max-age 和上一次资源请求的时间相加</strong>并与此次的资源请求时间做比较，若请求时间小于相加值，就直接使用缓存数据库中所缓存的资源。</p>
<h3 id="3-Cache-Control-相较于-Expires-的优势"><a href="#3-Cache-Control-相较于-Expires-的优势" class="headerlink" title="3) Cache-Control 相较于 Expires 的优势"></a>3) Cache-Control 相较于 Expires 的优势</h3><p>上文已经说过 Cache-Control 和 Expires 分别是 HTTP 1.1 和 HTTP 1.0 用于强缓存的 HTTP 响应头属性。那么为什么有了 Expires 后，还要在新版本中增加多一个 Cache-Control？ Cache-Control 主要是用来解决以下几个问题：</p>
<ol>
<li><code>Expires</code> 的值是服务端生成的一个绝对时间，这样的话若客户端与服务端存在时差，就会出现缓存命中误差的情况。</li>
<li><code>Expires</code> 缺少更加精确控制强缓存的特性，如 <code>Cache-Control</code> 中的：private、public、no-cache、no-store 等等</li>
</ol>
<h2 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2.协商缓存"></a>2.协商缓存</h2><p>协商缓存顾名思义，就是让客户端与服务端协商当前所缓存的资源是否还是有效可用。而服务端一般在客户端第一次进行资源请求时使用如下两种 HTTP 响应头部属性，告知客户端下次再请求该资源时，在请求头附上在上一次服务端响应时所接收到的属性值来让服务端进行缓存资源的有效性和可用性的判断。</p>
<h3 id="1-Last-Modified-与-If-Modified-Since"><a href="#1-Last-Modified-与-If-Modified-Since" class="headerlink" title="1) Last-Modified 与 If-Modified-Since"></a>1) Last-Modified 与 If-Modified-Since</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务端响应头部</span><br><span class="line">...</span><br><span class="line">Last-Modified: Wed, 21 Oct 2019 00:00:00 GMT</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 客户端请求头部</span><br><span class="line">...</span><br><span class="line">If-Modified-Since: Wed, 21 Oct 2019 00:00:00 GMT</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>Last-Modified</code> 是服务端用于协商缓存的 HTTP 1.0 <strong>响应头属性</strong>，而 <code>If-Modified-Since</code> 则是客户端用于协商缓存的 HTTP 1.0 <strong>请求头属性</strong>，其值一般是资源在服务端的最后修改时间。</p>
<ul>
<li>在客户端第一次向服务端请求资源时，服务端会在其响应头部加入 <code>Last Modified</code> 属性，告知该资源的最后修改时间</li>
<li>客户端在接收到服务端的响应后会按照响应头中的缓存标识，在缓存数据库中存入资源及其缓存标识</li>
<li>在客户端下一次请求该资源时，会在响应头中加入 <code>Last-Modified</code> 对应的响应头属性 <code>If-Modified-Since</code> 并填上其值。</li>
<li>服务端接收请求后就会取出客户端请求头中的 <code>If-Modified-Since</code> 属性值与该资源的最后修改时间做比较：<ul>
<li>若资源的最后修改时间大于 <code>If-Modified-Since</code> 的值，说明资源有更新的版本，返回 200 状态响应，并在响应头中设置新 <code>Last-Modified</code> 属性值和在其请求体中附上更新的资源</li>
<li>若资源的最后修改时间小于 <code>If-Modified-Since</code> 的值，说明资源无更新的版本，返回 304 状态响应，告知客户端资源无更新，可以使用所缓存的资源</li>
</ul>
</li>
</ul>
<h3 id="2-Etag-和-If-None-Match"><a href="#2-Etag-和-If-None-Match" class="headerlink" title="2) Etag 和 If-None-Match"></a>2) Etag 和 If-None-Match</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务端响应头部</span><br><span class="line">...</span><br><span class="line">ETag: &quot;44a64df551425fcc55e4d42a148795d9f25f89d5&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 客户端请求头部</span><br><span class="line">...</span><br><span class="line">If-None-Match: &quot;44a64df551425fcc55e4d42a148795d9f25f89d5&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>跟上文一样，<code>Etag</code> 也是服务端用于协商缓存的<strong>响应头属性</strong>，而 <code>If-None-Match</code> 同样也是客户端用于协商缓存的<strong>请求头属性</strong>，不过 <code>Etag</code> 和 <code>If-None-Match</code> 是在 HTTP 1.1 中才出现的，并且其值是资源在服务端的唯一标识（生成规则由服务端决定）。</p>
<ul>
<li>在客户端第一次向服务端请求资源时，服务端会在其响应头部加入 <code>Etag</code> 属性，告知该资源的唯一标识</li>
<li>客户端在接收到服务端的响应后会按照响应头中的缓存标识，在缓存数据库中存入资源及其缓存标识</li>
<li>在客户端下一次请求该资源时，会在响应头中加入 <code>Etag</code> 对应的响应头属性 <code>If-None-Match</code> 并填上其值</li>
<li>服务端接收请求后就会取出客户端请求头中的 <code>If-None-Match</code> 属性值与该资源目前的唯一标识做比较：<ul>
<li>若不一致，说明资源有更新的版本，返回 200 状态响应，并在响应头中设置新 <code>Etag</code> 属性值和在其请求体中附上更新的资源</li>
<li>若一致，说明资源无更新的版本，返回 304 状态响应，并在响应头中设置 <code>Etag</code> 属性值（与 <code>Last-Modified</code> 不同），告知客户端资源无更新，可以使用所缓存的资源</li>
</ul>
</li>
</ul>
<h3 id="3-Etag-相较于-Last-Modified-的优势"><a href="#3-Etag-相较于-Last-Modified-的优势" class="headerlink" title="3) Etag 相较于 Last-Modified 的优势"></a>3) Etag 相较于 Last-Modified 的优势</h3><p>上文已经说过 Etag/If-None-Matach 和 Last-Modified/If-Modified-Since 分别是 HTTP 1.1 和 HTTP 1.0 用于协商缓存的 HTTP 响应和请求的头属性。那么为什么有了 Last-Modified 后，还要在新版本中增加多一个 Etag？Etag 主要是用来解决以下几个问题：</p>
<ol>
<li>一些文件的修改时间也许会被周期性的修改，但其内容并无变化，这个时候就不希望客户端重新获取该资源</li>
<li>某些文件的修改非常频繁，比如在秒级以内的短期修改，而 Last-Modified 检测到的时间最小粒度仅为秒级，这样就无法精确的让客户端获取资源的最新版本</li>
<li>某些服务端无法精确的得到资源的最后修改时间</li>
</ol>
<p>这时，利用 Etag 就能更加精确的控制资源缓存，因为 Etag 是服务端程序自动生成的资源唯一标识，资源每次变动 ，都会生成新的 Etag 值。<strong>并且 Last-Modified 和 Etag 是可以同时使用，但是 Etag 优先级要高于 Last-Modified。</strong></p>
<h1 id="缓存步骤整体概括"><a href="#缓存步骤整体概括" class="headerlink" title="缓存步骤整体概括"></a>缓存步骤整体概括</h1><ol>
<li>在客户端第一次 HTTP 请求服务端资源时，服务端会把该资源的强缓存标识和协商缓存标识（如：Expires、Cache-Control、Last-Modified、Etag 等头部属性）设置于 HTTP 响应的头部中</li>
<li>客户端在接收到服务端的响应后，会把响应头部的相关缓存标识与资源一同存入缓存数据库中</li>
<li>客户端再次请求该资源时，会先到本地的缓存数据库中查找是否存在该资源的缓存，资源缓存存在时，则会取出当时一同存入的服务端强缓存标识中资源的有效期值（如：Expires 的值、Cache-Control 的 max-age 的值）进行如下判断：<ul>
<li>若还处于强缓存的有效期内，则直接使用所缓存的资源</li>
<li>若已经过了强缓存有效期，则判断是否存在协商缓存标识（如：Last-Modified、Etag）<ul>
<li>若存在协商缓存标识，则在请求服务端的请求头中设置对应的协商缓存标识（如：If-Modified-Since、If-None-Match）</li>
<li>若不存在协商缓存标识，则直接请求服务端获取资源，<strong>后续将轮回到第 1 步</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201119214520.png" alt="HTTP缓存概括"></p>
<h1 id="Cache-Control-的-max-age-0-和-no-cache-的区别"><a href="#Cache-Control-的-max-age-0-和-no-cache-的区别" class="headerlink" title="Cache-Control 的 max-age=0 和 no-cache 的区别"></a>Cache-Control 的 max-age=0 和 no-cache 的区别</h1><p>他们两个在浏览器操作上的区别就是，max-age=0 相当于用户在浏览器按下了 F5（CTRL+R） 进行刷新操作，而 no-cache 则是相当于用户在浏览器同时按下了 CTRL+F5 进行了强制刷新操作。那么它们其本质的区别是什么？好奇宝宝请看下面：</p>
<ol>
<li><p>max-age=0：当客户端在请求头中设置 Cache-Control 属性且值为 max-age=0 时，那么客户端会从缓存数据库中取出所缓存资源的 Etag（或 Last-Modified），并在请求头中设置 Etag （或 Last-Modified）在 HTTP 请求中所对应的 If-None-Match（或 If-Modified-Since） 属性（没错 Etag 和 Last-Modified 是 HTTP 响应头部的属性），服务端在收到请求后，会取出 If-None-Match（或 If-Modified-Since） 的值并找到对应的资源进行如下判断：</p>
<ul>
<li>若无更新则返回 304 状态响应，告知客户端资源无更新，可以使用所缓存的资源</li>
<li>若有更新则返回 200 状态响应，并在响应头设置新 Etag（或 Last-Modified） 属性值和在其请求体中附上更新的资源</li>
</ul>
</li>
<li><p>no-cache：当客户端在请求头中设置 Cache-Control 属性且值为 no-cache 时，那么客户端将无视缓存数据库中所缓存的资源和其 Etag，直接向服务端发送一个全新的资源请求。</p>
</li>
</ol>
<p>最后用一张图说明用户行为对 HTTP 缓存的影响</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201120002635.png" alt="用户行为对缓存的影响"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>缓存</tag>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title>更优雅的JavaScript 1</title>
    <url>/2019/12/13/more-elegant-javascript-1/</url>
    <content><![CDATA[<p>貌似，现在大家写代码都只是在追求其极致性能、精巧体积、华丽技巧，而忽视了最重要的”<strong>code for humans</strong>“。</p>
<p>我们知道在日常项目开发时，代码被人阅读的难度是远高于执行引擎的。所以要写出好的代码就需要尝试脱离自己的视角，以第三人的眼光重新审视、理解其上下文的含义。 这样创作出的代码结构、组合、技巧才会予人阅读的幸福感。我们致力于书写优秀的代码就意味着，代码不仅仅是一个工具，更是将其视作为用来传达精神、思想、理念的一座桥梁。这是一种对于书写者智慧的锤炼与分享。</p>
<a id="more"></a>

<h1 id="1-优先使用-const"><a href="#1-优先使用-const" class="headerlink" title="1. 优先使用 const"></a>1. 优先使用 const</h1><p><code>const</code> 在 JS 中不仅可以用于命名常量，且因为其内存地址不可变的性质，所以也常用于声明数组与对象。在编程中多使用 <code>const</code> 代替 <code>let</code> 和 <code>var</code>，可以在风格上向 immutable 靠拢，在编程思维上开始摒弃副作用带来的影响。更多的使用 <code>const</code> 虽然可能会使声明项增多，但是对于开发者来说，摒弃副作减少了心智负担的同时，让命名语义化将会使代码的质量大大提升。</p>
<p>而在 JS 中如果过多的使用 <code>let</code> 或者 <code>var</code> 声明变量，阅读者往往需要把注意力游离于代码上下文，反复阅读才能理解当前变量的值，并且变量还可能会被其他函数引用更改。所以，显而易见地，使用变量越多其理解的成本也就越高，而且还很难跟踪其具体的值。以下代码统计数组中每个元素的总和，使用 <code>const</code> 命名一个常量后，你将无法在 <code>forEach</code> 的每一次循环时改动它。转而使用 <code>reduce</code>，我们减少了变量 <code>let count</code>，增加了常量 <code>const count</code>。这样，在随后的代码的引用中就无需担心变量的状态。因为，我们知道，此时的 <code>count</code> 是一个数值常量，一旦赋值就不会变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  count += item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> count = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="2-使用函数表达式优于函数声明"><a href="#2-使用函数表达式优于函数声明" class="headerlink" title="2. 使用函数表达式优于函数声明"></a>2. 使用函数表达式优于函数声明</h1><p>我们配合上文所提到的 <code>const</code>，能够使用函数表达式来创建一个函数，更多的时候我们会与箭头函数搭配 <code>const func = () =&gt; &#123;&#125;</code>。 这种方式优于传统函数声明的地方在于：</p>
<ul>
<li>语义化指名函数是不可变的</li>
<li>函数表达式可以被看作赋值语句，更加简单易懂，且无法覆盖（常量不能被重新声明且重复赋值）</li>
<li>函数声明在代码解析阶段会被引擎提升，存在先使用后声明的情况。高可读可预测的代码应该先声明再使用</li>
<li>搭配箭头函数使用减轻对 <code>this</code> 的思维依赖</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> addOne = <span class="function">(<span class="params">value</span>) =&gt;</span> value + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="3-使用-return-减少分支"><a href="#3-使用-return-减少分支" class="headerlink" title="3. 使用 return 减少分支"></a>3. 使用 return 减少分支</h1><p>分支泛滥问题在 JS 代码中很是普遍，推荐在可能的代码块中使用 <code>return</code> 优先返回。这样可以有效的减少分支泛滥的问题，同时也能使代码逻辑更加的清晰可读，因为在同一时间能总是只能做一件事情。</p>
<p>我们还可以在必要时优先 <code>return</code> 较短的逻辑块，使代码更加美观。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">    <span class="comment">// server code</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// client code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">    <span class="comment">// server code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// client code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-不要过度优化"><a href="#4-不要过度优化" class="headerlink" title="4. 不要过度优化"></a>4. 不要过度优化</h1><p>如果你不是在编写类库、框架、底层代码等对性能要求极为苛刻的工程时，请务必过度以代码的可读性来换取代码的高效率。大多数的过度优化会让代码的可读性急剧下降，得不偿失！</p>
<ol>
<li>不必要的减少内存空间使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> fullname;</span><br><span class="line">users.forEach(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  fullname = user.firstname + user.lastname;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  register(fullname);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">users.forEach(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullName = user.firstname + user.lastname;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  register(fullname);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不必要的运算优化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> len = users.length;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">i = <span class="number">0</span>; i &lt; len; i++&gt;</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">users.forEach(<span class="function"><span class="params">user</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="5-减少魔术字符"><a href="#5-减少魔术字符" class="headerlink" title="5. 减少魔术字符"></a>5. 减少魔术字符</h1><p>魔术字符串指的是，在代码之中多次出现，与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除这些魔术字符，改由清晰的变量代替。</p>
<p>而通常，我们还会把所有的字符或数字统一声明在一个常量的文件内，如 <code>host</code> <code>defaultSettings</code> <code>port</code> 等等，这将会有益于后期维护工作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&quot;https://api.example.com&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;host&#125;</span>/1/users`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&quot;https://api.example.com&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> apiVersion = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> apis = &#123;</span><br><span class="line">  users: <span class="string">&quot;users&quot;</span>,</span><br><span class="line">  goods: <span class="string">&quot;goods&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;host&#125;</span>/<span class="subst">$&#123;apiVersion&#125;</span>/<span class="subst">$&#123;apis.users&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h1 id="6-函数不要有过多的参数"><a href="#6-函数不要有过多的参数" class="headerlink" title="6. 函数不要有过多的参数"></a>6. 函数不要有过多的参数</h1><p>在不断变动的需求中，我们编写的函数可能会有越来越多的参数。但要注意一点，当一个函数有较多的参数时，就会给调用方带来困扰。我们并非需要把每一个函数都实现 <strong>curry</strong>，但减少函数参数、合并参数、拆分函数功能都会让代码的可读性与拓展性更上一个台阶。</p>
<p>在调用较多参数的函数时，我们不仅要记住每个参数的位置，若有参数空缺时还需对其进行补位（如传入 <code>null</code> <code>undefined</code>），这会导致声明与调用的代码中都被迫存在非常多的冗余判断。所以在参数个数出现增长时，就可以考虑将其中的一部分合成一个参数对象，或是将函数内的功能进行拆分，作为一个新的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">id, name, telephone, email, address, createBy</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">id, userOptions</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="7-保持函数的专注"><a href="#7-保持函数的专注" class="headerlink" title="7. 保持函数的专注"></a>7. 保持函数的专注</h1><p>在一个函数里最好只做一件事，同时最好让函数的名字与做的这件事与之相关联，尤为重要！在单个函数中累积逻辑，会给阅读者带来非常大的心智负担，如果我们尝试函数拆分、组合并合理化命名，将会使代码整体获得极大的美感。使代码井井有条，泾渭分明也是一门别样的艺术。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> header = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> options = <span class="comment">// ...</span></span><br><span class="line">    options.header = headers;</span><br><span class="line">    <span class="keyword">const</span> host = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(id.length &gt; <span class="number">1</span>) <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> fetch(url, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> makeOptions = <span class="function">() =&gt;</span> &#123; <span class="comment">// ... &#125;;</span></span><br><span class="line"><span class="keyword">const</span> makeUrl = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="comment">// ... &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = makeOptions();</span><br><span class="line">    <span class="keyword">const</span> url = makeUrl(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fetch(url, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-使用语义化命名代替冗长的判断条件"><a href="#8-使用语义化命名代替冗长的判断条件" class="headerlink" title="8. 使用语义化命名代替冗长的判断条件"></a>8. 使用语义化命名代替冗长的判断条件</h1><p>过长的判断条件可能会在编写的当下烂熟于心，但常常会在一段时间回头再看觉得匪夷所思，很难理解其中的逻辑。所以，将其使用语义化的常量代替则可以向阅读者提示其含义，更是省下了不必要的注释，可真是一举两得！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为青少年</span></span><br><span class="line"><span class="keyword">if</span> (user.age &lt; <span class="number">19</span> &amp;&amp; user.age &gt; <span class="number">13</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> isTeenAgeMember = user.age &gt; <span class="number">13</span> &amp;&amp; user.age &lt; <span class="number">19</span>;</span><br><span class="line"><span class="keyword">if</span> (isTeenAgeMember) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-减少函数的副作用"><a href="#9-减少函数的副作用" class="headerlink" title="9. 减少函数的副作用"></a>9. 减少函数的副作用</h1><p>减少函数副作用一直以来都是 JS 社区中的长青话题，特别是 React 社区，而减少副作用并非总是需要以纯函数来解决所有问题。所以无需紧张，我们知道副作用会使得状态变化难以捕捉，在编程中应当以编写较少的副作用函数为目标，使函数的预期与实际保持一致的同时又不会造成过多的“噪音”。虽然，这或许会在构思和声明阶段花费一些时间，但对于整体代码的质量来说，是一件以小换大的好事！</p>
<p>你可能会发现有些时候不可避免的引用并改变了函数外部的状态，比如缓存某些值，为此你陷入了重构的苦恼。事实上不必过于忧虑，你想做的必然有其道理。这就是<strong>编程中取舍</strong>的问题，学会在编程、架构、工程上有所取舍（并不是随心所欲）后构建出的产品，自然会带有一定的特色。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> user = getUser();</span><br><span class="line"><span class="keyword">const</span> upload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  user.tempField = <span class="string">&quot;temp content&quot;</span>;</span><br><span class="line">  <span class="comment">// fetch user...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> user = getUser();</span><br><span class="line"><span class="keyword">const</span> upload = <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> tempUser = &#123; ...user, <span class="attr">tempField</span>: <span class="string">&quot;temp content&quot;</span> &#125;;</span><br><span class="line">  <span class="comment">// fetch user...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>更优雅的JavaScript 2</title>
    <url>/2020/01/15/more-elegant-javascript-2/</url>
    <content><![CDATA[<p>接着上一文，在<a href="/2019/12/13/more-elegant-javascript-1/">更优雅的 JavaScript 1</a>中，我们聊到了基础的 JavaScript 编写的建议。包括如何可靠的声明变量、常量、函数、以及利用合适的函数构建合适的逻辑，现在我们思考改善代码的第一步，如何命名？</p>
<p>在我们开始阅读代码之前，编码风格与命名方式会比代码的抽象方式、设计技巧更令我们印象深刻。很多时候也会为项目的整体风格定下基调。如果你阅读过一些算法工程师写的代码，常常会看到<em>单字母变量</em>、<em>反复的声明</em>，<em>不知所以的赋值与拷贝</em>、<em>累赘的条件判断</em>等等。我们虽不能说这样有问题，因为他们的代码大多的确是可以正常的运作，甚至在运行的时间或空间效率上有一些优势。但这在工程，特别是大型工程中是不值得称道的，根据经验我们可以把这类代码归类为“屎山”，充其量是“堆”了一摊高性能的“屎山”。</p>
<p>而我们现在做的则是脱离“编程只不过是工具”的阶段，脱离“屎山男孩”，让机器面有喜色、富有人性，使阅读者在某个瞬间也能切实的感受到创作者的思维跳动与审美哲学。</p>
<a id="more"></a>

<h1 id="1-富有准确性的命名"><a href="#1-富有准确性的命名" class="headerlink" title="1. 富有准确性的命名"></a>1. 富有准确性的命名</h1><p>事实上，你完全可以使用 <code>doSomeThing</code> 来命名所有的函数，毕竟它们真的只是提供某些微不足道的功能。但当你有了多个，甚至是成百上千个函数时，这将是一场灾难。这是一个浅显易懂的道理，即便是毫无经验的开发人员也会意识到命名爆炸的问题，他们隐约明白了什么是好的编程风格。但最后，甚至是大多数都止步于 <code>doSomeThing</code> 到“优美”之间的某一个站上。然后他们心里就默念，这就够了。</p>
<ol>
<li> 命名只需要有必要的词，除非有需求，否则不要堆砌</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> theBook = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> _book = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bookObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> theNewBook = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可读的条件判断</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> prefix = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> availableName = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> hasPrefixName = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可读的函数</li>
</ol>
<p>当我们要从网络上获取用户信息时，<code>getUser</code> 就不是一个准确的表达，<code>get</code> 太过于宽泛，它该表示是从数据库获取还是从网络获取？是以用户名获取还是用 ID 获取？这都有区别，现在我们可以先从命名的层面上思考它们的区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> fetchUserByName = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> findOneUserByID = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good(any environment, any params)</span></span><br><span class="line"><span class="keyword">const</span> getUsers = <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>准确的表达</li>
</ol>
<p>属性可以避免不必要的描述，言简意赅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  bookname: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  length: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  pages: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意单复数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> book = findBooks();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> books = findBooks();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>不必要的约定</li>
</ol>
<p>通常在示例或无意义的遍历中，我们会把每一个回调函数的参数写作 <code>item</code> <code>value</code> <code>element</code> 等等，这在一些场景中的确可以让阅读者忽略掉不必要的描述，从而专注于逻辑本身。但这并非总是合适，特别是我们需要表达状态的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> titles = books</span><br><span class="line">  .map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.title)</span><br><span class="line">  .filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.length &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> titles = books</span><br><span class="line">  .map(<span class="function">(<span class="params">book</span>) =&gt;</span> book.title)</span><br><span class="line">  .filter(<span class="function">(<span class="params">title</span>) =&gt;</span> title.length &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="2-观察与思考"><a href="#2-观察与思考" class="headerlink" title="2. 观察与思考"></a>2. 观察与思考</h1><p>观察是一个模糊的概念，可以尝试让同事朋友阅读你的代码，问问他们的感觉，哪些命名生硬，哪些词不达意，哪些又能让他们产生共鸣。一个可学习的方式就是在 <code>GitHub</code> 上阅读代码，你也能注意到开发者们的情绪波动，这里真的需要这些定义吗？这里有必要写的这么短小精悍吗？这里是不是写的太过于 <code>OC</code> 风了。试图从阅读代码理解开发者创作时的想法是很有趣的一件事件，这些情绪的波动还可能能让你明白他们大约处于编程、人生、情感的什么状态，有助于你深刻的理解接口与设计。</p>
<p>在一个项目中见到 <code>created</code> 时，便可以知道这调用发生在 <code>create</code> 之后，而非之前或者之中。以此类推便可以有 <code>destroyed</code> 或其他函数。如果项目是来自富有经验的开发者，这些细节会帮助你在代码中极快的理解作者的构思。</p>
<p>在阅读某些源码时，我们可能会注意到一些细节，就是一些旧有的功能被改变了，程序员只能被迫去修改这些已有的接口使之兼容。同时想要与原有的风格保持一些同步，有时也会衍生出一些新的接口，他们被置于一些结构体中，随着时间的推移可以推理，未来的一些接口也会被移入这些结构体 ———— 这就是我们对于命名的观察与思考。我曾经看见过有人说“狗是人类的朋友，taobao 的文档连狗都不如”，这就是他们观察的结果了，虽然好像令人不那么开心。</p>
<h1 id="3-巧妙与投机取巧"><a href="#3-巧妙与投机取巧" class="headerlink" title="3. 巧妙与投机取巧"></a>3. 巧妙与投机取巧</h1><p>我们可以断定<strong>巧妙</strong>是优雅命名中最重要的一部分，比如 <code>rvm</code> 与其他的一些命令行工具中的 uninstall 功能，其命令为 <code>implode</code> 。这好像有点意思，是吧？但事实上我见到的绝大多数的巧妙不过是“投机取巧”，他们苦心孤诣的作品是一大段没有说明的八进制、二进制代码，一堆三元堆砌的单行逻辑，一些谐音名字，以及不合时宜的正则表达式等等，这并不漂亮，这是歧路。</p>
<ol>
<li>自作聪明的谐音</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> markdowm2html = <span class="function">(<span class="params">template</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> markdownToHmtl = <span class="function">(<span class="params">template</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以语义化的正则</li>
</ol>
<p>代码并非是越简短越好，虽然多数场景下，我们需要尽可能的避免长篇累牍。但在必要时，可以使用命名和语义化的代码块来试图说明逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> isUser = <span class="regexp">/^name/</span>.test(user.name) &amp;&amp; <span class="regexp">/^http/</span>.test(user.url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> isUserName = user.name.starstWith(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isUrl = user.blog.startsWith(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isUser = isUserName &amp;&amp; isUrl;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>优美</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> hasDirOrCreateDir = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> ensureDir = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>粗解TCP的流量控制和拥塞控制</title>
    <url>/2019/06/30/tcp-traffic-and-congestion-control/</url>
    <content><![CDATA[<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="1-什么是流量控制"><a href="#1-什么是流量控制" class="headerlink" title="1. 什么是流量控制"></a>1. 什么是流量控制</h2><p>在 TCP 传输中，如果数据发送方的发送速度过快，那么就会造成数据接收方来不及接收所有发送出的数据。那么在这样的状况下，就会有分组丢失的情况发生。控制数据发送方的发送速度，使得数据接收方来得及接收，这就是流量控制。</p>
<h2 id="2-流量控制的目的"><a href="#2-流量控制的目的" class="headerlink" title="2. 流量控制的目的"></a>2. 流量控制的目的</h2><p>流量控制的其根本目的就是防止 TCP 传输中的分组丢失，它是构成 TCP 可靠性传输的其中一个方面。</p>
<h2 id="3-如何实现流量控制"><a href="#3-如何实现流量控制" class="headerlink" title="3. 如何实现流量控制"></a>3. 如何实现流量控制</h2><p>TCP 传输的流量控制由<strong>滑动窗口协议</strong>（<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82"><strong>连续 ARQ 协议</strong></a>）实现的，滑动窗口协议既能保证分组无差错、有序接收，也实现了流量控制的功能。主要的方式就是接收方在返回的 ACK 中会包含自己的接收窗口大小，并利用该接收窗口大小来实现控制发送方的数据发送。</p>
<a id="more"></a>

<hr>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="1-什么是拥塞控制"><a href="#1-什么是拥塞控制" class="headerlink" title="1. 什么是拥塞控制"></a>1. 什么是拥塞控制</h2><p>拥塞控制是一种用来调整 TCP 链接单次发送分组数量（<strong>单次发送量</strong>，通常叫 cwnd）的算法</p>
<h2 id="2-拥塞控制的目的"><a href="#2-拥塞控制的目的" class="headerlink" title="2. 拥塞控制的目的"></a>2. 拥塞控制的目的</h2><p>拥塞控制的其根本目的是防止通信子网中某一部分的分组数量过多，使得该部分的网络来不及处理，导致该通讯子网乃至整个网络性能下降的现象发生。严重的话还会导致网络通信业务陷入停顿，既出现死锁的现象。</p>
<p>其实就是类似于平时深圳公路网中常见的交通拥挤一样，当节假日出行的车辆大量增加时，各种走向的车流互相干扰。不仅如此，还有各路段不停修路，最终导致的堵车。</p>
<h2 id="3-如何实现拥塞控制"><a href="#3-如何实现拥塞控制" class="headerlink" title="3. 如何实现拥塞控制"></a>3. 如何实现拥塞控制</h2><p>在讲如何实现拥塞控制之前，需要介绍两个概念，第一个就是<strong>拥塞窗口 cwnd</strong>（<strong>congestion window</strong>），而第二个则是慢开始门限 <strong>ssthresh</strong>（<strong>slow start thresh</strong>）。<strong>后面的内容将会用 cwnd 和 ssthresh 代指它们两个</strong>，下面是对这两个概念的具体解释：</p>
<ol>
<li><p>发送方会维持一个拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且会根据实际情况动态变化。发送方让自己的发送窗口大小等于拥塞窗口大小，另外考虑到接收方的接受能力，发送方的发送窗口可能还需要小于拥塞窗口。</p>
</li>
<li><p>为了防止拥塞窗口增长过快，发送方还会维持一个慢开始门限变量，一旦到达慢开始门限的值后就会从慢开始算法转为执行拥塞避免算法。</p>
</li>
</ol>
<h3 id="1-慢开始算法"><a href="#1-慢开始算法" class="headerlink" title="1) 慢开始算法"></a>1) 慢开始算法</h3><p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是由小到大逐渐增加 cwnd 的大小。从下图可以看到，一个传输轮次所经历的时间其实就是往返时间 RTT，而且每经过一个传输轮次，cwnd 就加倍。所以慢开始里的“慢”并不是指 cwnd 增长的速率慢，而是指在 TCP 传输开始发送报文段时，初始设置的 cwnd 较小，然后再指数式增大。这当然会比，在初始就设置为较大的 cwnd 一下子把许多报文段注入到网络中要“慢的多”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201026180823.png" alt="慢开始算法"></p>
<p>为了防止慢开始算法，让 cwnd 走上无止境的指数式增长的道路，上面提到的 ssthresh 就起到了关键的作用。ssthresh 的具体作用如下，所以在这里可以看出慢开始算法和拥塞避免算法在拥塞控制中是相辅相成的：</p>
<ol>
<li>当 <strong>cwnd &lt; ssthresh</strong> 时，就执行慢开始算法；</li>
<li>当 <strong>cwnd &gt; ssthresh</strong> 时，就改为执行拥塞避免算法；</li>
<li>当 <strong>cwnd = ssthresh</strong> 时，慢开始与拥塞避免算法任选。</li>
</ol>
<h3 id="2-拥塞避免算法"><a href="#2-拥塞避免算法" class="headerlink" title="2) 拥塞避免算法"></a>2) 拥塞避免算法</h3><p>拥塞避免算法的思路就是让 cwnd 缓慢增长，即每经过一个往返时间 RTT 就把发送方的 cwnd +1，而不是指数式的加倍。这样有助于 cwnd 按线性规律的缓慢增长。另外无论是在慢开始算法阶段还是拥塞避免算法阶段，只要发送方判断网络出现拥塞（主要是根据有没有定时的收到接收方的确认，虽然没有收到确认可能是其他原因造成的。但是无法判断具体原因，所以都当做拥塞来进行处理），就把 ssthresh 设置为出现拥塞时的发送窗口大小的一半（但不能小于 2），然后把 cwnd 重新置为 1，然后改为执行慢开始算法（这样做的目的是要迅速减少发送方发送到网络中的分组数，使得拥塞的网络中的路由器有足够的时间把积压的分组处理完毕）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201026183338.png" alt="拥塞避免算法"></p>
<ol>
<li>cwnd 初始化为 1 个报文段，ssthresh 初始值为 16</li>
<li>开始执行慢开始算法，指数增长到第 4 轮，既 cwnd=ssthresh=16，然后改为执行拥塞避免算法，cwnd 按加法增长（线性规律增长）</li>
<li>假定 cwnd=24 时，网络出现超时（拥塞），则设置 ssthresh 为出现拥塞时的发送窗口大小的一半，既 ssthresh=12，cwnd 重新设置为 1，然后改为执行慢开始算法。当 cwnd=ssthresh=12 时，为避免拥塞，改为执行拥塞避免算法</li>
</ol>
<h3 id="2-快重传算法"><a href="#2-快重传算法" class="headerlink" title="2) 快重传算法"></a>2) 快重传算法</h3><p>快重传算法的思路就是要求接收方在收到 1 个失序的报文段后就立即发出重复确认（为的是让发送方及早知道有报文段没有到达）。快重传算法规定，发送方只要一连收到 3 个重复确认（确认丢失段的前一个段）就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201026185311.png" alt="快重传算法"></p>
<h3 id="4-快恢复算法"><a href="#4-快恢复算法" class="headerlink" title="4) 快恢复算法"></a>4) 快恢复算法</h3><p>快重传算法一般与快恢复算法配合使用，快恢复算法的思路就是当发送方连续收到 3 个重复确认时，就执行“乘法减少”算法，设置 ssthresh 为遇到突发情况时发送窗口大小的一半预防网络发生拥塞，考虑到如果网络出现了拥塞就不会接收到好几个重复确认，所以发送方认为现在网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 减半后的值，然后改为执行拥塞避免算法，使 cwnd 缓慢增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201026190649.png" alt="快恢复算法"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>流量控制主要作用于接收方，它是控制发送方的发送速度从而使接受方能够来的急接收发送方所发送的数据，防止分组丢失的控制方法。由<strong>滑动窗口协议</strong>（<strong>连续 ARQ 协议</strong>）实现，滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制的功能。<br>拥塞控制则作用于网络，它是防止过多的数据注入到传输的网络中，避免网络负载过大的情况发生。常用的控制方法如下：</p>
<ol>
<li>慢开始算法+拥塞避免算法</li>
<li>快重传算法+快恢复算法</li>
</ol>
<p>另外，慢开始算法只是在 TCP 传输建立时和网络出现超时时才使用。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>流量控制</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title>粗解为什么HTTPS需要七次握手</title>
    <url>/2019/07/18/why-https-laency/</url>
    <content><![CDATA[<p>毋庸置疑，目前互联网世界里 HTTP 协议（Hypertext Transfer Protocol）已经是大家日常网上冲浪时最常用的应用层协议。但是，由于 HTTP 其本身主要就是用于传输超文本的网络协议，并不会保证所传输的数据是否安全可靠。所以，在使用 HTTP 协议进行密码数据传输时，就类似于在通往数据接收方的路上，走着一个衣服上写着密码内容的人。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201104152419.png" alt="SSL发展史"></p>
<p>由于使用 HTTP 协议就如同让数据在大街上裸奔的原因，所以网景（Netscape）在 1995 年设计了 HTTPS 协议，使用了安全套接字层（Secure Sockets Layer：SSL）保证数据传输的安全可靠。随着传输层安全协议协议（Transport Layer Security）的发展，我们目前已经用 TLS 替代了废弃的 SSL 协议，而一般现在所说的 SSL 都是代指 TLS。</p>
<p>所以，可以说 HTTPS 是对 HTTP 协议的一种扩展，由于其基于了传输层的安全协议，我们得以可以使用它在互联网上安全地上网冲浪，传输私密数据等等。然而 HTTPS 从第一次发出建立连接请求到连接成功建立发送数据，<strong>这中间需要七次握手存在 4.5 倍的往返延迟（Round-Trip Time：RTT），比 HTTP 要多出几倍。</strong>所以，今天在这里就粗解一下其中的过程及其原因。</p>
<ol>
<li>TCP 协议，通信双方三次握手建立 TCP 连接</li>
<li>TLS 协议，通信双方四次握手建立 TLS 连接</li>
<li>HTTP 协议，客户端向服务端发送请求，服务端反馈响应</li>
</ol>
<p>我们可以从上面就可以看出，多出的往返延迟应该是在 TLS 协议的握手阶段产生出来的。而我们下面所做的分析都是建立在特定版本的协议实现以及常见场景上。因为，随着网络技术的发展，网络协议的迭代升级，一些新版本的协议已经通过新的机制优化掉多余通信往返，在后面我们会略带一提。</p>
<a id="more"></a>

<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>HTTP 协议作为应用层协议，它底下需要依赖传输层协议作为其提供数据传输功能的基础，而 HTTP 协议一般都会使用 TCP 协议作为其底层的传输层协议。为了阻止历史连接的错误建立，TCP 协议通信的双方会通过三次握手的机制进行连接的建立，而先前我已经写过一篇文章详细分析为什么 TCP 建立个连接得握三次手，在这里我们简单回顾一下 TCP 链接建立的整个过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201102140120.png" alt="TCP三次通信建立连接"></p>
<ol>
<li>客户端向服务端发送含有 SYN 控制标识以及初始序列号 SEQNO 值为 100 的数据段</li>
<li>服务端收到数据段后，向客户端发送含有 ACK、SYN 控制标识以及确认序列号 ACKNO 值为 101 和初始序列号 SEQNO 值为 200 的数据段</li>
<li>客户端收到数据段后，向服务器发送含有 ACK 控制标识以及确认序列号 ACKNO 值为 201 的数据段</li>
</ol>
<p>TCP 连接的双方会通过三次握手，确定 TCP 连接所需的初始序列号、窗口大小以及最大数据段，这样通信双方就能利用数据段中的序列号保证双方的数据不乱、不重、不漏，又通过窗口大小控制流量并以最大数据段大小控制自身所传输数据段的大小避免其下层 IP 协议对数据包进行分片。</p>
<p>以前 TCP 协议为了交换建立连接所需的信息迫不得已需要进行三次握手，甚至如今大多数场景下也是无法避免。不过在 2014 年所提出的 TCP 开启（TCP Fast Open：TFO）却可以在某些特定场景下通过一次通信建立 TCP 连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201104174440.png" alt="TCP Fast Open"></p>
<p>TCP 快启使用的策略是 TCP 连接建立之初，客户端在向服务端发送含有 SYN 控制标识以及初始序列号值的数据段时会在其数据段内标记快启选项，服务器收到数据段后，会生成一个 TFO Cookie 并将其放在包含 ACK、SYN 控制标识以及确认序列号值和初始化序列号值的数据段中发往客户端，客户端收到数据段后会把 Cookie 储存下来。当客户端与服务端重新建立连接时，它会发送含有 SYN 控制标识以及初始序列号值和所存储的 Cookie 的数据段重新与服务端建立 TCP 连接，服务端校验客户端数据段内所携带的 Cookie 无误后，就向客户端发送含有 ACK、SYN 控制标识以及确认序列号值和初始化序列号值的数据段，随后开始传输数据，这样下来就能在后续的连接建立中减少通信的次数。</p>
<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><p>由于 TLS 其本身并不提供传输的可靠性保障，所以 TLS 是构建在 TCP 协议之上的，用以在 TCP 协议上构建安全的传输通道。在通信双方建立可靠的 TCP 协议连接之后，就需要通过 TLS 握手交换双方的密钥，在这里我们主要介绍 TLS 1.2 版本的连接建立的握手过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201104191345.png" alt="TLS四次握手"></p>
<ol>
<li>客户端向服务端发送 Client Hello 消息，其中携带客户端所支持的协议版本、加密算法、压缩算法以及客户端生成的随机字符串</li>
<li>服务端收到客户端支持的协议版本、加密压缩算法等信息后<ol>
<li>向客户端发送 Server Hello 消息，并携带特定的协议版本、加密算法、压缩算法、会话 ID、服务端生成的随机数</li>
<li>向客户端发送 Certificate 消息，即：网站证书链，其中包含证书所证明的网站域名、签署方、有效期等信息</li>
<li>向客户端发送 Server Key Exchange 消息，传递公钥以及签名等信息</li>
<li>向客户端发送可选的 CertificateRequest 消息，要求验证客户端的证书</li>
<li>向客户端发送 Server Hello Done 消息，通知服务端已经发送了全部的相关信息</li>
</ol>
</li>
<li>客户端收到服务端的协议版本、加密算法、压缩算法、网站证书等等信息，校验网站证书无误后<ol>
<li>向服务器发送 Client Key Exchange 消息，包含使用服务端公钥加密后的随机字符串，即：预主密钥（Pre Master Key）</li>
<li>向服务端发送 Change Cipher Spec 消息，通知服务端后续的数据会使用加密传输</li>
<li>向服务端发送 Finished 消息，其中包含加密后的握手信息</li>
</ol>
</li>
<li>服务端收到客户端的 Change Cipher Spec 和 Finished 消息后<ol>
<li>向客户端发送 Change Cipher Spec 消息，通知客户端后面的数据段会使用加密传输</li>
<li>向客户端发送 Finished 消息，验证客户端的 Finished 消息并完成 TLS 握手</li>
</ol>
</li>
</ol>
<p>TLS 握手的关键在于利用通信双发生成的随机字符串和服务端的证书公钥生成一个双方经过协商后的对称密钥，这样通信双方就可以使用这个对称密钥在后续的数据传输中加密消息数据，防止中间人的监听和攻击，保证通讯安全。</p>
<p>而在 TLS1.2 中，我们需要 2 RTT 才能建立 TLS 连接，但是 TLS 1.3 经过优化协议，将原本两次往返延迟降低至一次，大幅度减少了建立 TLS 连接所需要的时间和资源，让客户端可以在 1 RTT 之后就能立即向服务端传输应用层的消息数据，而在这里就不详细介绍 TLS 1.3 是如何建立连接的了。除了减少常规的握手开销外，TLS 1.3 还引入了 0 RTT 连接建立的特性，可以让原本的 40% 的连接可以通过该特性建立连接，而该特性与 TCP 协议的 TFO 的实现原理较为相似，其策略都是通过存储会话信息和重用会话信息来实现的，所以存在一定的安全风险。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>在已经建立好的 TCP 和 TLS 的通道上传输数据是很简单的事情了，HTTP 协议可以直接利用其下层可靠且安全的连接通道进行数据传输。TCP 解决了数据不乱、不重、不漏，而 TLS 解决了数据的安全问题，可谓铜墙铁壁般。由于 HTTP 是通过 TCP 的套接字接口向服务端写入消息数据，服务端在接受到数据且处理后会通过相同的途径返回消息数据。因为整个过程需要客户端发送请求以及服务端返回相应，所以整个流程是需要 1 RTT。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201104191348.png" alt="HTTP请求响应"></p>
<p>由于进行数据交换的操作时 1 RTT 已经是极限，所以 HTTP 协议本身已经是没有可优化的空间了。不过随着请求的数量逐渐增加，利用 HTTP/2 就可以复用已经建立的 TCP 连接减少 TCP 和 TLS 握手带来的额外开销。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如文章一开始所提到的，HTTPS 需要七次握手，其中各层中所需要的握手次数情况如下：</p>
<ol>
<li>TCP 协议，通信双方三次握手建立 TCP 连接</li>
<li>TLS 协议，通信双方四次握手建立 TLS 连接</li>
<li>HTTP 协议，客户端向服务端发送请求，服务端反馈响应</li>
</ol>
<p>TCP 协议通过三次握手，确定建立连接所需的初始序列号、窗口大小以及最大数据段，这样通信双方就能利用数据段中的序列号保证双方的数据不乱、不重、不漏，又通过窗口大小控制流量并以最大数据段大小控制自身所传输数据段的大小避免其下层 IP 协议对数据包进行分片。TLS 协议通过四次握手，交换建立安全连接中所需的协议版本、加密算法、压缩算法、客户端服务端随机数、网站证书等信息，依据这些信息来协商出后续数据传输中所需要的对称加密密钥。HTTP 再利其下层的 TLS 与 TCP 所建立好的安全可靠的连接通道进行消息的发送和接收。</p>
<h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul>
<li><a href="/2019/03/01/why-tcp-connection-need-three-way-handshake/">为什么 TCP 建立个连接得握三次手</a></li>
<li><a href="/2019/06/30/tcp-traffic-and-congestion-control/">粗解 TCP 的流量控制和拥塞控制</a></li>
<li><a href="/2019/05/31/why-tcp-ip-protocol-fragemented-my-packet/">为什么 TCP/IP 要拆分我的数据</a></li>
<li><a href="/2019/04/04/why-tcp-sticky-my-packet/">为什么 TCP 要粘我的数据包</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么TCP建立个连接得握三次手</title>
    <url>/2019/03/01/why-tcp-connection-need-three-way-handshake/</url>
    <content><![CDATA[<p>互联网发展至今日这个样子，TCP 协议脱不了这个“干系”。TCP 协议已然成为我们日常网络生活中必定会接触到的网络协议，因为绝大多数的网络连接都是建立在其之上。而学习过计算机网络基础或对 TCP 协议稍有了解的人应该都知道，TCP 协议在其连接建立之前需要经过三次握手（three-way handshake）。</p>
<p>而对于 TCP 协议三次握手的建立过程，我相信很多 IT 人在准备面试时都一定会先再熟悉一番。但是一般都很少会去深究其为什么需要握三次手？我相信很多人应该都没有办法回答这个问题。所以今天在这里就让我们稍微深究一下其原因，而在深究前，我想先抛出一个对于三次握手错误的类比，这个类比错误的误导了很多人，也包括我在内。而这个错误的类比如下：</p>
<ol>
<li>你好，请问在不在？</li>
<li>我在的，请问你还在吗？</li>
<li>我还在！</li>
</ol>
<p>说这是一个错误的类比的原因在于，它只以片面的以相似性解释了三次握手的表层含义，而并没有把其正正的原因从其表面展露出来。而这种类比带来的解释往往就只有这样片面的相似性，它只有在我们想要通俗易懂地介绍事物的特性时才能发挥较大的作用。而文章后面的篇幅会侧面的解释该类比存在的问题，好！那我们就继续往下。</p>
<a id="more"></a>

<h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>很多人在思考这个问题的时候其实关注点都放在了三次握手的<strong>三次</strong>上面，这虽然很重要。但是如果我们选择重新审视这个问题，我们对于所建立的连接中的<strong>连接</strong>是否是真的清楚？只有知道<strong>连接的定义</strong>，才能尝试回答为什么 TCP 协议建立连接需要三次握手。</p>
<blockquote>
<p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p>
</blockquote>
<p><a href="https://tools.ietf.org/html/rfc793">RFC793 - Transmission Control Protocol</a> 文档中非常清楚的定义了 TCP 协议中的连接是什么东西，在这里简单的总结一下：<strong>为了保证传输可靠性和流的控制机制</strong>，TCP 协议需要为每个<strong>数据段初始化和维护其状态信息</strong>，而这些<strong>状态信息由：sockets、序列号（sequence no: SEQ）和窗口大小（window size）组成</strong>，然后这些数据段发送与接收就构成了 TCP 协议连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201031224224.png" alt="构成TCP连接的根本要素"></p>
<p>所以，建立 TCP 连接其根本就是要让通信双方对于以上三个要素达成共识。而连接中的 sockets 是由互联网地址和端口号组成，即：IP + 端口。窗口大小则主要用来做流控制，最后的序列号则是用来确定连接发起方发送的数据段序列号，接收方可以通过序列号与发送方确认包的成功接收。那么既然这样，问题好像就被转换成了：<em>为什么需要三次握手才能初始化 sockets、序列号和窗口大小？</em> 那么我们就继续顺着网线，分析并查找答案！</p>
<h2 id="历史连接"><a href="#历史连接" class="headerlink" title="历史连接"></a>历史连接</h2><p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 文档中其实就提到了 TCP 连接使用三次握手的首要原因，其解释是：为了防止历史的重复建立连接请求而引起连接错乱，最终导致 TCP 协议通信双方建立了错误的连接。</p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201101015627.png" alt="TCP两次通信建立连接造成的混乱"></p>
<p>可以想象一个场景，如果通信双方建立连接的通信只有两次，那么发送方一旦发出建立连接请求后，它就没办法撤回这一请求。如果在网络情况复杂或者网络状态差的场景下，发送方在想与接收方建立连接时，连续的发送了多次建立连接的请求。此时假设 TCP 协议建立连接只通信两次，那么接收方就只能选择接受或者拒绝，它并不知道此次所收到的建立连接的请求是否是因为网络堵塞，而已被发送方置为过期的请求。</p>
<p>因为这个原因，TCP 协议选择采用了三次握手并在其数据段头引入了 RST 控制标识，当接收方收到请求时就会将发送方发来的 SEQ + 1 发回给对方，这时由发送方根据接收到的 SEQ + 1 的值来判断当前连接是否是历史连接：</p>
<ol>
<li>如果发送方判断所收到的 SEQ + 1 的值属于已经过期的 SEQ，那么当前连接就是历史连接，发送方会直接发送数据段，并将段头中的 RST 控制标识置为 1，要求终止这一次连接</li>
<li>如果发送方判断 SEQ + 1 的值不属于已经过期的 SEQ，那么发送方就会发送数据段，并将段头中的 ACK 控制标识置为 1，通信双方就会成功建立连接</li>
</ol>
<p>使用三次握手和 RST 控制标识，将连接的是否建立的最终控制权交给了发送方，这是因为只有发送方有足够的上下文信息判断当前进行建立的连接是否存在错误或过期，这也是 TCP 选择使用三次握手建立连接的主要原因。</p>
<h2 id="初始序列号"><a href="#初始序列号" class="headerlink" title="初始序列号"></a>初始序列号</h2><p>而另一个使用三次握手的重要因素就是，通信双方都需要交换对方所用于发送消息的初始序列号。TCP 协议作为一个标称可靠的传输层协议，需要在稳定性不确定的网络环境中解决各种可能产生的问题，而最常见的问题如下：</p>
<ol>
<li>数据段被发送方多次发送造成数据重复</li>
<li>数据段在传输过程中被链路中的设备丢失</li>
<li>数据段到达接收方后顺序被打乱</li>
</ol>
<p>为了解决以上的这些可能存在的问题，初始序列号就起到了至关重要的作用。而 TCP 协议要求发送方在数据段中必须加入序列号字段，有了该序列号，就可以：</p>
<ol>
<li>接收方通过序列号对重复的数据段进行去重处理</li>
<li>发送方会在对应数据段未被 ACK 的情况下进行重发</li>
<li>接收方可以根据数据段内的序列号进行数据段的重新排序</li>
</ol>
<p>所以说序列号在 TCP 协议连接起至关重要的作用并不是空谈，而该初始序列号作为 TCP 协议数据段内的一部分，也就需要发送方在三次握手的第一阶段发送带有 SYN 控制标识数据段时一同在 SEQ 字段赋上初始序列号的值，而接收方则在接收到 SYN 控件标识的数据段后，需要回复带有 ACK 控制标识和值为 SEQ + 1 的确认序列号数据段与之进行确认。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201102135809.png" alt="TCP四次通信建立连接"></p>
<p>如上图所示，通信双方都分别向对方发送包含 SYN 和 ACK 控制标识的数据段，使对方获取了自己所设置的初始序列号之后连接就建立了。<strong>由于 TCP 协议数据段头中的巧妙设计，以至于一个数据段头内可同时包含 ACK 和 SYN 控制标识，所以接收方就可以把中间的两次通信合二为一，这也就帮助我们将通讯次数减少为三次。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201102140120.png" alt="TCP三次通信建立连接"></p>
<p>除此之外，由于网络作为一个分布式系统，其中并不存在一个用于计数的全局计数器，并且 TCP 可能具有不同的机制来选择初始序列号。接收方在接收第一个包含 SYN 控制标识的数据段时无法知道该数据段是否是因为网络阻塞而刚到达的旧延迟数据段，除非接收方记住了连接上使用的最后一个序列号。这样可行性会比较低，因为一旦这样接收方要记的东西就太多了，但是让发送方记录下发出的序列号来判断连接是否过期就可行的多。</p>
<h2 id="通信次数"><a href="#通信次数" class="headerlink" title="通信次数"></a>通信次数</h2><p>当我们讨论 TCP 建立连接需要的通信的次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次、四次或者更多次？讨论使用更多的次数来建立连接往往是没有建设性意义的。因为我们总是可以使用更多的通信次数交换相同的东西。而我们追求的其实是用最少的通信次数完成预期的信息交换。也就是我们在上面所说的<em>两次握手</em>没办法建立 TCP 连接，而<em>四次握手</em>又有点多余，所以通过精心设计的数据段头（同时包含 SYN 和 ACK 控制标识）以至于最终可以达到三次握手就能建立 TCP 连接。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章开始我们把关注点从<strong>为什么要三次握手</strong>才能建立 TCP 连接上，转向了<strong>什么是 TCP 连接</strong>，从而使建立 TCP 连接的本质浮出水面。而 TCP 连接有着非常清楚的定义：为了保证传输可靠性和流的控制机制，TCP 协议需要为每个<strong>数据段初始化和维护其状态信息</strong>，而这些<strong>状态信息由：sockets、序列号（sequence no: SEQ）和窗口大小（window size）组成</strong>，然后这些数据段发送与接收就构成了 TCP 协议连接。</p>
<p>TCP 建立连接时通过三次握手可以有效的避免历史连接的错误建立，减少通信双方产生不必要的资源消耗，三次握手能帮助通信双方获取初始序列号，有了初始序列号的存在能够保证数据段在传输的过程中不重不乱不丢。到这里我想为什么不使用<em>两次握手</em>和<em>四次握手</em>的原因已经非常明了了。</p>
<ul>
<li>两次握手：无法避免历史连接的错误建立，导致资源浪费</li>
<li>四次握手：TCP 协议数据段头中的精心设计，让一个数据段可以同时存在 SYN 和 ACK 控制标识，以至于可以把接收方的两次发送合二为一，减少了通信次数带来的消耗</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>连接</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么TCP/IP要拆分我的数据</title>
    <url>/2019/05/31/why-tcp-ip-protocol-fragemented-my-packet/</url>
    <content><![CDATA[<p>TCP/IP 作为目前互联网举足轻重的网络通信协议，不是没有它的道理。TCP/IP 提供供了点对点的链接机制，以让源主机中的源进程发出的数据能够送达目标主机的目标进程里去，这其中的<strong>资料封装、寻址、传输、路由、接收</strong>都会以标准化的操作完成，并且它们还能保证数据在传输过程中<strong>有序</strong>、<strong>不重</strong>、<strong>不漏</strong>。</p>
<p>但是你不知道的是，当应用层协议使用传输层的 TCP 协议进行数据传输时，传输层 TCP 协议可能会将应用层所发送的消息分成多个数据段，我们一般称呼它叫：<strong>TCP 分段</strong>。而在其下层的网络层 IP 协议也有可能会对传输层 TCP 协议的数据段分成多个数据包，我们一般称呼它叫：<strong>IP 分片</strong>。但是由于 TCP 协议会自行先分段，所以正常情况下都轮不到 IP 协议进行分片。那为什么它们要拆分我们的数据呢？又为什么 TCP 协议自行分段后，就没 IP 协议什么事了呢？我们带着这些疑问继续探索。</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201031123646.png" alt="TCP分段IP分包"></p>
<p>在开始之前，我们先达成共识：</p>
<ol>
<li>协议层中传输数据的基本单位统称为：Data Unit（数据单元）</li>
<li>网络层 IP 协议传输的数据单元称为：Packet(包）</li>
<li>传输层 TCP 协议传输的数据单元称为：Segment（段）</li>
<li>传输层 UDP 协议传输的数据单元称为：Datagram（报）</li>
<li>应用层传输的数据单元称为：Message（消息）</li>
</ol>
<p>并且，我们把前提摘要先提前放出来：</p>
<ol>
<li>IP 协议会分片传输过大的数据包避免物理设备的限制</li>
<li>TCP 协议会分段传输过大的数据段保证整体的传输性能，同时避免遭到 IP 协议分片</li>
</ol>
<h1 id="最大传输单元和-IP-协议分片"><a href="#最大传输单元和-IP-协议分片" class="headerlink" title="最大传输单元和 IP 协议分片"></a>最大传输单元和 IP 协议分片</h1><p>IP 协议适用于传输数据包的协议，作为网络层协议，它能提供数据的<strong>路由</strong>和<strong>寻址</strong>功能，让数据能通过网络到达目的地。但是由于现实中物理设备的限制，导致传输于网络中的数据包不能太大，所以在不同设备进行数据传输前，需要先确定一个 IP 数据包的大小上限，<strong>既最大传输单元</strong>（MTU）,MTU 是 IP 数据包能够传输的数据大小上限。</p>
<p>MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，但会增加丢包所带来的风险。更小的 MTU 意味着更低的网络延迟，但太小又会让额外开销加大。所以有一个合适 MTU 值对于网络传输来说是非常重要的，每一个物理设备都自己的 MTU，两个主机之间的 MTU 依赖其底层的网络能力，它由整个链路上 MTU 最小的那台物理设备所决定。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201031133126.png" alt="链路MTU发现"></p>
<p><strong>路径最大传输单元发现</strong>（Path MTU Discovery，PMTUD）是用来确定两个主机数据传输 MTU 的机制，它的工作原理如下：</p>
<ol>
<li>向目标主机发送数据包头 DF 控制位设置为 1 的 IP 数据包 ，DF 是不分片（Don’t Fragment）的缩写</li>
<li>路径上的物理设备会根据数据包的大小和自己的 MTU 比较，做出不同的决定：<ol>
<li>如果数据包的大小大于设备的 MTU，就会丢弃数据包并发回一个包含该设备 MTU 的 ICMP 的消息</li>
<li>如果数据包小于设备的 MTU，就会继续向目标主机传递数据包</li>
</ol>
</li>
<li>源主机收到 ICMP 消息后，会不断使用新的 MTU 发送 IP 数据包，直到 IP 数据包到达目标主机</li>
</ol>
<blockquote>
<p>ICMP 是互联网控制协议（Internet Control Message Protocol），它能在 IP 主机之间传递控制消息</p>
</blockquote>
<p>位于第二层的以太网协议对其<strong>数据帧的数据栏位</strong>限制一般都是 1500 字节，所以在一般情况下，IP 主机的路径 MTU 都是 1500，扣除 IP 协议数据包头部占用的 20 字节，则如果数据包内的数据大于 1480 字节，那么 IP 协议就开始拆分我们的数据，把数据分到多个数据包中分片传输。</p>
<p>IP 协议的数据包分片对于传输层协议是透明的，假设我们使用 UDP 协议传输 2000 字节的数据，加上 UDP 协议报头占用的 8 字节，则 IP 协议需要传输 2008 字节的数据。但是当 IP 协议发现自己的路径 MTU 是 1480 字节时，它察觉到其要传输的数据 2008 字节大于 MTU 的 1480 字节，就会手起刀落对 UDP 的数据报进行拆分。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201031141508.png" alt="IP协议对UDP数据报进行分片"></p>
<p>具体分片后的情况如下：</p>
<ol>
<li>20 字节 IP 协议数据包头 + 8 字节 UDP 协议数据报头 + 1472 字节数据</li>
<li>20 字节 IP 协议数据包头 + 528 字节数据</li>
</ol>
<p>目标主机在接收到数据包时会对分片的数据进行重组，不过因为第二个数据包中不包含 UDP 协议的相关信息，一旦发生丢包，那整个 UDP 数据报就无法重新组合。如果 UDP 数据报需要传输的数据过多，那么 IP 协议就会抄起家伙大量分片，增加了数据传输的不稳定性。如果 IP 协议没有数据包大小的限制，那么上层可以以消息为单位传输数据，自然就不存在分片和组合的需求，不过因为物理设备 MTU 的限制，想要保证数据传输的可靠性和稳定性还是需要传输层的配合。</p>
<h1 id="IP-协议分片与-TCP-最大分段大小"><a href="#IP-协议分片与-TCP-最大分段大小" class="headerlink" title="IP 协议分片与 TCP 最大分段大小"></a>IP 协议分片与 TCP 最大分段大小</h1><p>TCP 协议是面向字节流的协议，应用层交给 TCP 协议的数据并不会以消息为单位往目标主机发送，并且 TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 链接的 MSS 是 MTU - 40 字节（IP 和 TCP 协议头部各占用 20 字节），既 1460 字节；不过如果通信双方没有指定 MSS 的话，在默认情况下 MSS 的大小是 536 字节。所以应用层交给 TCP 协议发送的数据大小如果大于 MSS 就可能会被拆分到多个数据段里。</p>
<p>IP 协议的 MTU 是物理设备上的限制，它限制了传输路径上能够发送数据包大小的上限。而 TCP 协议的 MSS 是操作系统内核层面的限制，通信双方会在三次握手时确定这次所建立连接的 MSS 值。一旦确定了 MSS，TCP 协议就会对应用层交给 TCP 协议发送的数据按 MSS 的大小进行拆分，构成多个数据段。而需要注意的是，IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包为单位组织数据，而 TCP 协议以数据段为单位组织数据。这一点在文章开始的达成共识时有提到过。</p>
<p>如下图所示，如果 TCP 连接 MSS 是 1460 字节，应用层想通过 TCP 协议传输 2000 字节的消息数据，那么 TCP 协议会根据 MSS 将 2000 字节的数据拆分到两个数据段中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201031154702.png" alt="TCP协议数据段进行分段"></p>
<p>最终分段后的情况如下：</p>
<ol>
<li>20 字节 IP 协议数据包头 + 20 字节 TCP 协议数据段头 + 1460 字节消息数据</li>
<li>20 字节 IP 协议数据包头 + 20 字节 TCP 协议数据段头 + 540 字节消息数据</li>
</ol>
<p>从应用层的角度来看，两个数据段中的 2000 字节数据构成了源主机想要发送的消息，但是 TCP 协议是面向字节流的，向协议写入的数据会以流的形式传递到对端。TCP 协议为了保证可靠性，会通过 IP 协议的 MTU 计算出 MSS 并根据 MSS 大小进行分段，以至于能够避免 IP 协议对装有数据段的数据包进行分片。因为 IP 协议对数据包的分片对于上层来说是透明的，如果上层协议不针对 MTU 做一些大小限制，那么 IP 协议进行分片操作时，将导致部分数据包里的部分数据与包含传输层的协议头的数据包分离，一旦数据包发生丢失就只能丢弃全部数据。损失惨重！</p>
<p>我们可以通过一个例子分析 MSS 存在的必要性。如下图所示，假设 TCP 协议中不存在 MSS 的概念，因为每个数据段的大小没有上限，当 TCP 协议交给 IP 协议各发送两个共 1600 字节的 IP 协议数据包时，由于物理设备的限制，IP 协议的路径 MTU 为 1500，所以 IP 协议会对数据包进行分片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201031164352.png" alt="IP协议第TCP协议数据段进行分片"></p>
<p>所以就会造成不存在 TCP 协议头的数据包，那么当 IP 协议进行数据传输时出现了丢包，TCP 协议的接收方就没办法对数据段进行重组，最终导致整个 TCP 数据段都需要重传，带来了更多的额外开销。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP/IP 拆分数据究根结底就是因为物理设备的限制：</p>
<ol>
<li>IP 协议则是因为数据包大于 MTU 后会被链路中的设备丢弃，为了避免被丢弃，IP 协议就需要通过路径 MTU 发现获取链路上的 MTU 值后，再抄起数据包分片大刀，把数据包大小大于 MTU 的一节一节砍断并把砍断的数据包重新封包发送。</li>
<li>而 TCP 协议则是为了避免自个的数据段被 IP 协议的分片大刀无情砍中，因为一旦砍中，那么就会首尾分离，就需要目标主机进行重组，产生不必要的性能消耗，万一传输途中还丢包了，就会前功尽弃需要全部重传。所以根据这个情况 TCP 协议自然的也就自觉的按造 MTU 算出自己的 MSS，然后再根据 MSS 学起 IP 协议抄起了分段大刀，利落的砍向了应用层传过来的待发送消息数据，并重新封段，拿给 IP 协议发送。</li>
</ol>
<h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul>
<li><a href="/2019/04/04/why-tcp-sticky-my-packet/">为什么 TCP 要粘我的数据包</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>数据包</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么TCP要粘我的数据包</title>
    <url>/2019/04/04/why-tcp-sticky-my-packet/</url>
    <content><![CDATA[<p>其实 TCP 粘包这个问题，在 TCP 的设计角度上看，其问题本质就是一个伪命题。但是为什么会有那么多的开发者提出这样的问题？我们从 TCP 设计的特性可以不难看出，TCP 本就是<strong>面向连接</strong>、<strong>基于字节流</strong>且<strong>可靠</strong>的传输层通信协议，所以在 TCP 的这个层面来说并不存在包的这个概念，也就没有粘包这么一说了。那按照这么说，粘包问题还能凭空出现的？</p>
<p>在开始之前，我们先达成共识：</p>
<ol>
<li>协议层中传输数据的基本单位统称为：Data Unit（数据单元）</li>
<li>网络层 IP 协议传输的数据单元称为：Packet(包）</li>
<li>传输层 TCP 协议传输的数据单元称为：Segment（段）</li>
<li>传输层 UDP 协议传输的数据单元称为：Datagram（报）</li>
<li>应用层传输的数据单元称为：Message（消息）</li>
</ol>
<a id="more"></a>

<h1 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h1><p>IP 协议在网络层解决了数据包的路由和传输问题，得以让基于其上层的传输层 TCP 协议不用再去关注路由和寻址，那么 TCP 就把这部分的注意力集中到了解决数据传输中的<strong>有序性</strong>和<strong>可靠性</strong>问题去了，以至于可以让其上一层协议不必担心所托付的数据能否排排坐的传输到接收方。只要被写入 TCP 协议缓冲区中的数据，协议栈几乎都能保证其数据的送达。</p>
<p>当应用层协议使用 TCP 协议进行数据传输时，TCP 协议可能会将应用层协议所发送的消息<strong>重新分割组合到多个数据段</strong>中并以字节流的形式依次发送。那么这样一个 TCP 的数据段可能就不会按应用层发送的消息一一对应上。而数据接收方收到的某个数据段就可能会由<em>多个应用层消息</em>组成，应用层从 TCP 接收缓冲区读取数据时就会发现粘连的消息，这时就需要对这些粘连的消息按消息边界规则进行拆分。那么总结下来，就是以下两点：</p>
<ol>
<li>TCP 协议是<strong>面向字节流</strong>的协议，它可能会<strong>重新分割组合</strong>应用层协议的消息到多个数据段中</li>
<li>应用层协议<strong>没有定义消息的边界</strong>，导致数据的接收方<strong>无法按边界拆分粘连的消息</strong></li>
</ol>
<h1 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h1><p>应用层交给 TCP 协议的数据并不会以包为单位向目标主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标主机。Nagle 算法是一种采用通过减少发送有效数据含量少的 TCP 数据段手段，以提升 TCP 传输性能的算法。因为网络宽带有限，它不会将数据含量很少的数据段直接发送到目标主机，而是会在 TCP 发送缓冲区中等待更多的待发送数据，这种延迟等待并批量发送数据的策略虽然会影响实时性，但是能够降低网络拥堵的可能性并减少额外开销。</p>
<p>在早期的互联网中，Telnet 是被广泛使用的应用程序，然而因为当时 Telnet 会产生大量只有 1 字节有效数据量的数据段，而这些数据段中都会存在包含 40 字节的协议描述信息。这带来的额外开销是很不乐观的，宽带的利用率只有仅仅的 2.44%，Nagle 算法就是在当时的这种使用场景下设计出来的。</p>
<p>当应用层协议通过 TCP 协议传输数据时，实际上待发的数据先被写入了 TCP 协议的发送缓冲区中，如果用户开启了 Nagle 算法，那么 TCP 协议可能不会立刻发送写入的数据，而是会等待缓冲区中的数据超过了最大数据段大小（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201030172902.png" alt="Nagle算法重新分割组合应用层协议消息"></p>
<p>Nagle 算法确实能够在有效数据较少时提高网络宽带的利用率减少 TCP 和 IP 协议描述信息所带来的额外开销，但是使用该算法也可能会导致应用层协议多次写入的数据被重新分割组合发送，当接收方从 TCP 协议栈中读取数据时就会发现不相关的数据出现在同一个数据段中，应用层可能也没有定义消息的边界，造成没有办法对他们进行拆分。</p>
<p>除了 Nagle 算法之外，TCP 协议中还有另一个用于延迟发送数据的选项 TCP_CORK，如果我们开启了该选项，那么发送的数据小于最大数据段大小时，TCP 协议就会延迟 200ms 发送该数据或者等待缓冲区中的数据超过最大数据段大小。</p>
<p>无论是 TCP_NODELAY 还是 TCP_CORK，他们都会通过延迟发送数据来提高宽带的利用率，他们会对应用层协议写入的数据进行重新分割组合，而这些机制和配合能够出现的最重要的原因是 — TCP 协议是基础字节流的协议，其本身没有数据包的概念，不会按照数据包的机制去发送数据。</p>
<h1 id="消息边界"><a href="#消息边界" class="headerlink" title="消息边界"></a>消息边界</h1><p>如果我们系统性地学习过 TCP 协议，那么设计一个基于 TCP 协议且能够被 TCP 协议任意分割组装消息的应用层协议就不会有太大的问题。既然 TCP 协议是基于字节流的，这其实就意味着应用层协议需要自己划分消息的边界。</p>
<p>如果我们能在应用层协议中定义消息的边界，那么无论 TCP 协议如何对应用层协议的消息进行重新分割组装，那么接收方都能根据约定的消息划分规则来恢复被重新分割组装后的消息。在应用层协议中，最常见的两种边界划分规则就是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201030195935.png" alt="应用程协议消息边界划分规则"></p>
<ol>
<li>基于长度</li>
<li>基础终结符（Delimiter）</li>
</ol>
<p>基于长度的实现有两种方式，固定长度将把应用层的消息都使用统一的大小，但这种固定长度的方式，当有效数据量小于该固定长度时就可能会出现资源浪费的情况。另外一种就是使用不固定长度，而这种方式需要在应用协议的协议头中增加表示数据负载的字段，这样接收方才可以从字节流中分离出不同的消息，HTTP 协议的消息边界就是基于长度实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UFT-8</span><br><span class="line">Content-Length: 150</span><br><span class="line">...</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述 HTTP 消息中，我们使用 <code>Content-Length</code> 头表示 HTTP 消息的数据负载大小，当应用层协议解析到足够多的字节数后，就能从中分离出完整的 HTTP 消息，无论发送方如何处理对应的消息，我们都可以遵循这一规则完成 HTTP 消息的恢复工作。</p>
<p>不过 HTTP 协议除了使用基于长度的方式实现边界划分，当发送的内容大小不确定时，也会使用基于终结符的策略，并使用块传输（Chunked Transfer）的机制。此时 HTTP 头中就不再包含 <code>Content-Length</code> 了，它会转而使用负载大小为 0 的 HTTP 消息作为终结符表示消息边界。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以这么说，TCP 粘包问题是因为应用层协议开发者的错误设计导致的，他们忽略了 TCP 协议数据传输的核心机制 — 基于字节流，其本身并不存在数据包的概念。所有在 TCP 中传输的数据都是以流的形式进行传输，所以这就需要应用层协议开发者行设计消息的边界划分规则。所以粘包总的来说还是以下两点：</p>
<ol>
<li>TCP 协议是<strong>面向字节流</strong>的协议，它可能会<strong>重新分割组合</strong>应用层协议的消息到多个数据段中</li>
<li>应用层协议<strong>没有定义消息的边界</strong>，导致数据的接收方<strong>无法按边界拆分粘连的消息</strong></li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>数据包</tag>
        <tag>粘包</tag>
      </tags>
  </entry>
  <entry>
    <title>从零一步步搭建属于自己的TypeScript+React开发环境</title>
    <url>/2020/02/15/step-by-step-build-ts-react-dev-env/</url>
    <content><![CDATA[<p>如果现在要开发一个 React 项目，那最快的方式应该就是直接使用 Facebook 官方开源的脚手架 <a href="https://github.com/facebook/create-react-app">creat-react-app</a>，简称：CRA。但是，随着项目的业务场景复杂度提升，难免会需要在开发环境里做一些配置上的调整。这个时候就只能把脚手架进行 eject 后，亲自上阵修改 Webpack 的配置了，即便是这样 CRA 对于 Webpack 的配置灵活度也是相对的不太高。如果这个时候对 Webpack 不够熟练的话，就会有种心有余而力不足的感觉。</p>
<p>想当初我为了要给公司的前端项目搭建开发环境时，也是被 Webpack 折腾的死去活来，配置 Webpack 的时候总是记不住配置里的那些字段，而且配置时还要牵扯到一系列的工具，像 ES6 编译器 Babel、CSS 预处理器 less/sass、CSS 后处理器 postcss，还有各种 webapck 的 loader 和 plugin。所以，在刚开始的一段时间里都还是直接 CRA 了事。不过在经过一段时间的毒打后，在后续的项目里逐渐的把 CRA 替换为自行搭建的开发环境。现在让我从零开始一个前端项目的话，我更多的会选择自己去搭建开发环境，其次才会去选择官方的 CLI。</p>
<p>而这篇文章最主要目的是想让大家（特别是新手）能够从零开始，一步一步搭建出一个完整的开发环境。然后在搭建的过程中，一点一点的了解每一步中所配置项的作用及其原理，每一个插件的作用及其影响并对比同功能插件的差别。只要跟着步骤来走，就一定能实现所说的同样功能。</p>
<p>先附上项目地址：<a href="https://github.com/aaronlam/webpack-typescript-react-practice2">webpack-typescript-react-practice2</a></p>
<a id="more"></a>

<h2 id="能学到什么"><a href="#能学到什么" class="headerlink" title="能学到什么"></a>能学到什么</h2><p>在大家通篇阅读及实践后，将会学到如下这些知识点：</p>
<ol>
<li>项目中常用的配置文件</li>
<li>项目统一代码风格和规范配置</li>
<li>项目统一代码提交规范配置</li>
<li>Webpack 基本配置</li>
<li>TypeScript + React 开发环境搭建</li>
<li>Webpack 公共构建环境优化</li>
<li>Webpack 开发构建环境优化</li>
<li>Webpack 生产构建环境优化</li>
</ol>
<h2 id="项目初始化及配置文件"><a href="#项目初始化及配置文件" class="headerlink" title="项目初始化及配置文件"></a>项目初始化及配置文件</h2><p>我使用的开发机和编辑器分别是 win 10 和 VSCode，Node 版本为 12.10.0，命令行使用的是 VSCode 中的 Terminal。在实践过程中所安装的全部依赖均为目前最新版本，并且文章会不定时更新，确保文章具有时效性。</p>
<h3 id="1-package-json"><a href="#1-package-json" class="headerlink" title="1. package.json"></a>1. package.json</h3><p>搭建项目的第一步就是新建项目文件夹，然后初始化项目，生成项目配置文件 package.json。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建项目文件夹</span></span><br><span class="line">mkdir webpack-react-typescript-practice</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换工作路径到项目文件夹</span></span><br><span class="line">cd $_</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化项目，生成项目配置文件</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>你可以将 <code>webpack-react-typescript-practice</code> 替换成你想要的项目名称，命令中的 <code>$_</code> 表示上一条命令的最后参数，在这里就表示项目文件夹名称。在初始化项目时，你也可以使用 <code>yarn</code> 进行初始化。但是在这里我们就以 <code>npm</code> 作为初始化工具，在后续的过程中也会用 <code>npm</code> 来进行依赖包的安装。</p>
<p>然后通过修改默认的项目配置文件后，内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;webpack-typescript-react-practice2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Quickly create react + typescript project development environment&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [<span class="string">&quot;react-typescript-project&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;aaronlam&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://www.aaronlam.xyz&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;a@aaronlam.xyz&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;bugs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/aaronlam/webpack-typescript-react-practice2/issues&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span>: <span class="string">&quot;https://github.com/aaronlam/webpack-typescript-react-practice2#readme&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂时修改了以下配置：</p>
<ul>
<li>description：增加了对该项目的描述，当项目 push 到 github 后，在 github 进行 repo 搜索时，关键字就会与 description 进行匹配</li>
<li>scripts：把默认生成的 test 项删除</li>
<li>keywords：增加了项目的关键字，当项目 publish 到 npm 后，开发者在 npm 搜索时，合适的关键字能更容易被搜索到</li>
<li>author：添加了项目的作者信息</li>
<li>license：修改了项目的协议</li>
</ul>
<h3 id="2-LICENSE"><a href="#2-LICENSE" class="headerlink" title="2. LICENSE"></a>2. LICENSE</h3><p>可以根据项目的性质，到网站 <a href="https://choosealicense.com/">choose a license</a> 选择一个合适的 license（一般没有特别的需求，都会选择较为宽松的 MIT 协议），复制到项目根目录下的 LICENSE 文件内即可，然后修改其中的年份和作者名，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">MIT License</span><br><span class="line"></span><br><span class="line">Copyright (c) [2020] [Aaronlam]</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure>

<h3 id="3-gitignore"><a href="#3-gitignore" class="headerlink" title="3. .gitignore"></a>3. .gitignore</h3><p>说到 <code>.gitignore</code> 配置文件，那我们就要先来一波 git 本地仓库初始化，执行以下命令来初始化 git 本地仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化git仓库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>git ignore，顾名思义就是让 git 选择性根据规则忽略掉一些文件的版本控制。VSCode 也会监听该文件之外的所有文件，如果没有进行忽略的文件有所改动时，在 git 进行提交时就会被识别为需要提交的文件。</p>
<p><code>node_modules</code> 是我们安装第三方依赖包的文件夹，这个是肯定要添加到 <code>.gitignore</code> 中的，且不说这个文件夹里面成千上万个文件会给编辑器带来的性能压力，也会给提交至远端的版本管理服务器造成不小的压力。另外就是这个文件夹内的东西，完全是可以通过命令 <code>npm install</code> 获取到。</p>
<p>所以不需要进行版本控制的文件或文件夹都要添加进来，比如项目中常见的：build, dist 文件夹等，还有操作系统中默认生成的，如 MacOS 系统生成的 DS_Store 文件等。但是，我们对于系统或者编辑器自动生成的文件并不都是了如指掌的，那么我们就可以通过 VSCode 的 <a href="https://marketplace.visualstudio.com/items?itemName=codezombiech.gitignore">gitignore</a> 插件来生成 <code>.gitignore</code> 文件常用的配置规则信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201126141031.png" alt="gitignore插件"></p>
<p>安装好插件后，<kbd>ctrl</kbd> + <kbd>shift</kbd> + <kbd>p</kbd> 唤出 VSCode 的命令面板，输入 <code>Add gitignore</code> 命令，即可在输入框继续输入系统或者编辑器名字，来自动生成相应需要忽略的文件或文件夹规则至 <code>.gitignore</code> 文件中。可操作多次，后续操作的规则信息将自动追加至 <code>.gitignore</code> 文件中。</p>
<p>我添加了以下几个忽略规则配置项：</p>
<ol>
<li>Node</li>
<li>Windows</li>
<li>MacOS</li>
<li>VSCode</li>
</ol>
<p>大家可以酌情添加，如果插件中没有的规则，可自行手动添加至 <code>.gitignore</code> 中，具体的配置规则可以<a href="https://git-scm.com/docs/gitignore">参考这里</a>，比如我自己就添加了 <code>dist</code> 和 <code>build</code>，用于忽略后续 webapck 打包构建出的文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201126143100.gif" alt="gitignore添加规则"></p>
<h3 id="4-npmrc"><a href="#4-npmrc" class="headerlink" title="4. .npmrc"></a>4. .npmrc</h3><p>众所周知，由于有股神秘不可抗拒的力量，国内无论是 github 还是 npm 的连接速度都是非常抽搐的。大家也不想在使用 npm 安装项目依赖包时，忍受着如龟速般的安装进度。所以我们一般都会在 Terminal 里输入以下命令把 npm 或 yarn 的源切换为淘宝的镜像源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registery https://registery.npm.taobao.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">yarn config set registery https://registery.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>又或者是全局安装 <code>nrm</code> 或者 <code>yrm</code>，使用这两个插件来进行 npm 或 yarn 源的切换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全局安装nrm</span></span><br><span class="line">npm i -g nrm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用nrm切换淘宝镜像源</span></span><br><span class="line">nrm use taobao</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过nrm ls可以看到其他的镜像源</span></span><br><span class="line">nrm ls</span><br><span class="line"></span><br><span class="line">  npm -------- https://registry.npmjs.org/</span><br><span class="line">  yarn ------- https://registry.yarnpkg.com/</span><br><span class="line">  cnpm ------- http://r.cnpmjs.org/</span><br><span class="line">* taobao ----- https://registry.npm.taobao.org/</span><br><span class="line">  nj --------- https://registry.nodejitsu.com/</span><br><span class="line">  npmMirror -- https://skimdb.npmjs.com/registry/</span><br><span class="line">  edunpm ----- http://registry.enpmjs.org/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或全局安装yrm</span></span><br><span class="line">yarn global add yrm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用yrm切换淘宝镜像源</span></span><br><span class="line">yrm use taobao</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过yrm ls可以看到其他的镜像源</span></span><br><span class="line">yrm ls</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>但是！</strong>大家想想，万一某个同学 clone 了你的项目之后，准备在本地开发的时，他先前并没有设置淘宝 npm 镜像源，这时他就需要进行一次以上的动作，又或者他正全然不知的忍受着龟速的依赖包安装进度。</p>
<p>而我们作为项目的搭建者，从便利性考虑应该创建 <code>.npmrc</code> 配置文件，而该配置文件是给 npm 使用的配置文件，当然如果你使用 yarn 的话，yarn 也会遵守 <code>.npmrc</code> 的配置，虽然 yarn 也有自己专门的配置文件 <code>.yarnrc</code>。随后我们在配置文件内把 npm 的源设置为淘宝的 npm 镜像源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建.npmrc文件</span></span><br><span class="line">touch .npmrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在该文件内输入配置</span></span><br><span class="line">registery=https://registery.npm.taobao.org/</span><br></pre></td></tr></table></figure>

<p>自此，我们在 npm 依赖包安装的速度上过上了小康生活！</p>
<h3 id="5-README-md"><a href="#5-README-md" class="headerlink" title="5. README.md"></a>5. README.md</h3><p><code>README.md</code> 就是项目的说明书，只要在 github 流浪过的开发人员肯定都会看到过项目底下的各种说明页面，而这些说明页面都是 github 根据 <code>README.md</code> 文件自动渲染显示的。而这个文件对于一个好的开源项目是无比重要的，且文件的内容要足够简洁清晰明了。</p>
<p>一般我们会在 <code>README.md</code> 里添加一些实用的 badges（徽章），例如持续集成工具 Travis CI 对于项目 build 状态的徽章，或者 denpendencies 版本是否过期的徽章等。而 badge 本质上就是一个链接，只不过文字部分换成了 svg 渲染的图片，我们可以在网站 <a href="https://shields.io/">shields.io</a> 中找到各种各样的 badge，平时逛 github 项目的时候看到喜欢的 badge 也可以收藏一下。</p>
<p>不过，由于我们的项目目前还没有实质性内容，所以先把 <code>README.md</code> 文件创建先，后续我们再回过头来补充他！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建README.md文件</span></span><br><span class="line">touch README.md</span><br></pre></td></tr></table></figure>

<h2 id="统一代码风格和规范配置"><a href="#统一代码风格和规范配置" class="headerlink" title="统一代码风格和规范配置"></a>统一代码风格和规范配置</h2><p>非常好呀！无惊无险的来到了非常重要的<strong>统一代码风格和规范配置</strong>章节，在多人共同开发一个项目的时候问题就是每个人的代码风格都会有所差异，随着项目版本的不停迭代，维护人员的不断更替。项目里的代码就会变得越来越不可维护，比如 jack、mike、nick 三人的开发风格如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// jack紧凑型风格</span><br><span class="line">const add=(a,b)=&gt;&#123;return a+b;&#125;</span><br><span class="line"></span><br><span class="line">// mike常规型风格</span><br><span class="line">const add =  (a, b) =&gt; &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// nick紧凑规范型风格</span><br><span class="line">var add = (a,b) =&gt; &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个刚接手这种项目的你，然而你又有强迫症，会不会顿时产生一个念头，<strong>人间不值得！</strong>如果我们从项目搭建的开始就有手段去约束项目中的代码风格，使其风格统一，将会极大地提升代码的可维护性，很重要的一点是能够关爱每位强迫症开发患者。</p>
<h3 id="1-EditorConfig"><a href="#1-EditorConfig" class="headerlink" title="1. EditorConfig"></a>1. EditorConfig</h3><p>EditorConfig 是跨编辑器维护代码风格一致性的规范，通过其 <code>.editorconfig</code> 文件，我们可以让多个开发人员，使用不同的编辑器时使代码格式化风格仍然能保持一致。有的 IDE 会直接内置 EditorConfig 规范，如：IDEA。但 VSCode 则需要安装<a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig For VS Code</a>插件来进行支持。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201126155008.png" alt="EditorConfig For VS Code插件"></p>
<p>安装完插件后，在 VSCode 中使用快捷键 <kbd>ctrl</kbd> + <kbd>shift</kbd> + <kbd>p</kbd> 唤出命令面板，输入 <code>Generate .editorcondig</code> 即可快速生成 <code>.editorconfig</code> 文件。但是，有时候因为 VSCode 抽风会时不时的找不到该命令，如果你恰好也找不到，那么我们就手动创建该配置文件把。</p>
<p>该配置文件的配置信息特别简单，就几个配置项，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root = true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br><span class="line">charset = utf-8</span><br><span class="line">trim_trailing_whitespace = true</span><br><span class="line">insert_final_newline = true</span><br><span class="line">end_of_line = unset</span><br></pre></td></tr></table></figure>

<p>在插件和配置都准备就绪后，编辑器就会先读取该配置文件，把配置文件内的格式化规则覆盖到编辑器默认的 Formatter 规则中。以下是对上面规则项的简单介绍：</p>
<ul>
<li>indent_style：缩进风格，可选的配置有 tab 和 space</li>
<li>indent_size：缩进大小，可设定为 1-8 的数字，设定多少就表示缩进多少个 tab/space</li>
<li>charset：编码格式，通常都是 utf-8</li>
<li>trim_trailing_whitespace：去除多余的空格，比如在末尾多打了个空格，则会自动去除</li>
<li>insert_final_newline：在末尾插入一空行，个人比较喜欢这个风格，大家喜欢的话也可以设为 true</li>
<li>end_of_line：换行符，可选的配置有 lf, cr, crlf, unset。有那么多选择的原因是因为各个操作系统之间的换行符不同导致的，Windows 的为 crlf，Linux 和现代 MacOS 为 lf，早期的 MacOS 为 cr。而这里我们设置为 unset，表示让其换行符遵守当前操作系统。</li>
</ul>
<h3 id="2-Prettier"><a href="#2-Prettier" class="headerlink" title="2. Prettier"></a>2. Prettier</h3><h4 id="EditorConfig-和-Prettier"><a href="#EditorConfig-和-Prettier" class="headerlink" title="EditorConfig 和 Prettier"></a>EditorConfig 和 Prettier</h4><p>上面我们使用了 EditorConfig 来为我们进行跨编辑器维护代码风格，Prettier 也是用来维护代码风格的东西，乍一看，两个东西的作用貌似是一样的呀。为什么同一个项目要配置两个格式化工具？我们可以看有些著名的开源项目如：React、VSCode 等就是两个都使用了，所以都用上自然有他们的道理。</p>
<p>首先 <strong>Prettier 分为 VSCode 插件和 Node 命令行工具</strong>，我们要搞清楚 EditorConfig 和 Prettier 的区别，就要先搞清楚 Prettier 的 VSCode 插件和 Node 命令行工具的区别。</p>
<p>Prettier 的 VSCode 插件和 Node 命令行工具本质上的区别在于：</p>
<ul>
<li>Prettier 插件是用于替换 VSCode 默认的 Formatter，开发者可以在编码的期间使用 VSCode 快捷键 <kbd>alt</kbd> + <kbd>shift</kbd> + <kbd>f</kbd> 触发格式化操作</li>
<li>Prettier 命令行工具是用于让开发者可以在命令行中通过使用 Prettier 提供的命令进行代码的格式化。但是通常我们不会在命令行中直接使用，而会与 eslint 以及 lint-staged 搭配使用<strong>（后面会提到）</strong></li>
</ul>
<p>他们俩的共同点就是都会通过<strong>读取 <code>.prettierrc</code> 配置文件，或者 <code>package.json</code> 项目配置文件中 prettier 属性里配置的格式化规则来设置其格式化风格</strong>。而不同的是 Prettier VSCode 插件还会读取插件设置界面中配置的格式化规则来设置其格式化的风格。</p>
<p>EditorConfig 和 Prettier 本质上的区别在于：</p>
<ul>
<li>EditorConfig 的配置文件格中的式化规则是<strong>直接覆盖编辑器内默认 Formatter 的规则，并且他的格式化规则是不涉及具体语言的</strong>，你配置了 <code>.editorconfig</code> 文件，当使用 VSCode 快捷键 <kbd>alt</kbd> + <kbd>shift</kbd> + <kbd>f</kbd> 进代码行格式化的时候，其格式化的代码风格就是 EditorConfig 所配置的风格。</li>
<li>Prettier 的 VSCode 插件是<strong>用于替代 VSCode 中默认的 Formatter，并且要根据具体的语言进行格式化。</strong>你启用了插件，并把该插件作为 VSCode 的默认 Formatter 的同时还通过配置文件配置了其格式化规则。当使用 VSCode 快捷键 <kbd>alt</kbd> + <kbd>shift</kbd> + <kbd>f</kbd> 进代码行格式化的时候，其格式化的代码风格就是 Prettier 所配置的风格</li>
<li>Prettier 命令行工具则是<strong>用于与其他命令行工具搭配使用</strong>，如：eslint、lint-staged 等</li>
</ul>
<p>所以总的来说，EditorConfig 与 Prettier 插件的功能大概相同，只是一个用于覆盖 VSCode 默认 Formatter 的格式化规则，而另外一个则是用于替代 VSCode 默认的 Formatter，他们两个都属于编辑器插件类的东西，<strong>一旦用 Prettier 插件替代了默认的 Formatter，那 EditorConfig 自然也就失效了。不过他们两个的配置文件内要是存在重合的格式化规则的时候，最好让他们保持一致！</strong>而 Prettier 命令行工具则是与他们属于不同维度的东西，他作用于命令行中与其他命令行工具搭配使用，从而在不同维度让代码的风格保持一致。</p>
<p>好了啰嗦了那么多，其目的就是让大家能够搞清楚他们三个的关联关系，以至于达到知其然知其所以然的效果。</p>
<h4 id="Prettier-Node-命令行工具"><a href="#Prettier-Node-命令行工具" class="headerlink" title="Prettier Node 命令行工具"></a>Prettier Node 命令行工具</h4><p>在我们的项目中执行以下命令安装 Prettier 命令行工具，使其成为我们项目中的第一个依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> i是intall简写，-D则是--save-dev简写，整体表示为以本地开发依赖安装</span></span><br><span class="line">npm i -D prettier</span><br></pre></td></tr></table></figure>

<p>安装完后，在根目录新建 <code>.prettierrc</code> 配置文件，并输入以下配置规则：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;tabWidth&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;semi&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;printWidth&quot;</span>: <span class="number">120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Prettier 官方秉承 opinionated 的原则，可以理解为独断专行，自以为是。所以其可配置的规则项还是很少的，大概 20 多个左右。大部分的规则已经按照社区的共识，以最佳实践、最好看的代码风格进行格式化了。下面就简单介绍上述的规则项，感兴趣的还可以去 <a href="https://prettier.io/playground/">Prettier Playground</a> 把玩把玩：</p>
<ul>
<li>trailingComma：对象的最后一个属性末尾会添加逗号，如：<code>&#123; a: 1, b: 2, &#125;</code></li>
<li>tabWidth：缩进大小（与 <code>.editorConfig</code> 的 <code>indent_size</code> 保持一致）</li>
<li>semi：分号是否添加</li>
<li>singleQuote：是否使用单引号</li>
<li>endOfLine：换行符号（与 <code>.editorConfig</code> 的 <code>end_of_line</code> 保持一致）</li>
<li>printWidth：单行代码最长长度，超过后会自动换行</li>
</ul>
<p>因为目前我们还没有代码文件，所以也就没办法在命令行里用 Prettier 展示一番他的威力。</p>
<h4 id="Prettier-VSCode-插件"><a href="#Prettier-VSCode-插件" class="headerlink" title="Prettier VSCode 插件"></a>Prettier VSCode 插件</h4><p>我们在 VSCode 中安装 <a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier - Code formatter</a> 插件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201126183753.png" alt="Prettier - Code formatter插件"></p>
<p>插件安装完后，我们在项目的根目录新建一个 <code>.vscode</code> 文件夹，然后在此文件夹下再新建一个 <code>settings.json</code> 文件。虽然是 <code>.json</code> 后缀的文件，但是其实是 <code>jsonc</code> 格式的文件，<code>jsonc</code> 和 <code>json</code> 文件的区别就在于，是否能添加注释，而这个 <code>c</code> 就是 <code>cmmont</code>（注释）的意思。</p>
<p>而该文件与 VSCode 的全局配置文件 <code>settings.json</code> 一样，都是用于配置 VSCode 的。但是该文件的优先级会高于 VSCode 全局的 <code>settings.json</code>，这样当别人 clone 了项目进行协同开发，也不会因为全局的 <code>settings.json</code> 的配置不同而导致 prettier 或后面会讲到的 eslint 或 stylelint 失效，接下来我们暂时添加以下内容到文件中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 指定哪些文件不参与搜索</span></span><br><span class="line">  <span class="attr">&quot;search.exclude&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;**/node_modules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;dist&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;yarn.lock&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定哪些文件不被VSCode监听，预防启动VSCode时扫描的文件太多，导致CPU占用过高</span></span><br><span class="line">  <span class="attr">&quot;files.watcherExclude&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;**/.git/objects/**&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;**/.git/subtree-cache/**&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;**/node_modules/*/**&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;**/dist/**&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 保存时，自动进行一次代码风格格式化</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 配置VSCode使用Prettier插件替代默认的Formatter</span></span><br><span class="line">  <span class="attr">&quot;[javascript]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[javascriptreact]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[typescript]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[typescriptreact]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[json]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[jsonc]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[html]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[css]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[less]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[scss]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[yaml]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[markdown]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>editor.formatOnSave</code> 的作用是在我们保存时，自动执行一次代码风格格式化，而不同的代码该使用什么格式化器？接下来的配置便是设置各种代码的默认格式化插件为 prettier，而该插件便会根据先前在项目根目录创建的 <code>.prettierrc</code> 配置文件中所配置的规则进行代码风格格式化。</p>
<p>既然都创建了 <code>.vscode</code> 文件夹，那就顺带一提我们还可以通过在 <code>.vscode</code> 文件夹下新建 <code>extensions.json</code> 文件，在文件中配置一些用于向别人推荐的 VSCode 插件。在他们打开该项目时，如果有推荐的插件未安装 VSCode 就会提示用户安装，他们也可以在插件市场勾选过滤条件只显示推荐的插件来查看，配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;recommendations&quot;</span>: [<span class="string">&quot;esbenp.prettier-vscode&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-ESLint"><a href="#3-ESLint" class="headerlink" title="3. ESLint"></a>3. ESLint</h3><p>在上面我们配置了 EditorConfig 和 Prettier ，他们俩都是为了<strong>解决代码风格格式化的工具</strong>，从解决的层面来说<strong>前者是解决通用代码风格，后者是解决具体语言代码风格</strong>。而 ESLint 则是<strong>用作代码风格、代码质量的规范化工具</strong>，虽然各种 lint 工具有一定的格式化代码的能力。但是其主要功能并不是负责代码格式化，所以代码格式化的工作就交由前面两个专门进行代码风格格式化的工具进行处理了。</p>
<p>ESLint 能在我们编写代码时帮助我们检测出代码可能出现的隐性问题，帮我们排除掉不良代码的“坏味道”，降低项目中 Bug 出现的机率，提高项目整体的代码质量。我们可以通过 ESLint 命令行工具提供的 <code>eslint --fix</code> 命令进行一些问题代码的转换。如：<code>var a = &#123;&#125;</code>，执行命令转换后：<code>const a = &#123;&#125;</code>。当然 ESLint 还有许多类似的强制转换代码为最佳写法的规则，而在无法自动转换时就会出现红线提示，强迫开发人员寻求更好的解决方案。</p>
<p>在我们的项目中执行以下命令安装 ESLint 命令行工具：</p>
<blockquote>
<p>很多的依赖包即可以全局安装，也可以作为本地开发依赖或生产依赖来安装。但在这里我们都选择以本地开发依赖来安装。因为，我们没办法确保别人在开发这个项目的时候也全局安装了依赖包，而且以本地开发以来或生产依赖安装还能确保大家使用的版本一致，避免不必要的麻烦。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D eslint</span><br></pre></td></tr></table></figure>

<p>安装成功后，执行以下命令，使用 ESLint 命令行工具所提供的交互式配置生成器，进行配置文件的生成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure>

<p>在继续交互式配置文件生成介绍前，我们先来了解一下 <code>npx</code> 是什么。<code>npx</code> 是 npm 5.2 自带的一个命令，其中的 <code>x</code> 就是和文件类型描述符的那个 <code>x</code> 一样表示 <code>execute</code> 执行的意思。该命令的意思是，如果本地安装了 <code>eslint</code> 就会使用本地的 <code>eslint</code>，否则就会去全局中查找，若全局中也没有找到，就在临时目录下载 <code>eslint</code>，执行完毕后删除。也就是说我们可以用以下两种方式的其中一种代替 <code>npx</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行项目本地的eslint</span></span><br><span class="line">./node_modules/.bin/eslint --init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者全局安装，执行全局的eslint</span></span><br><span class="line">npm i -g eslint</span><br><span class="line">eslint --init</span><br></pre></td></tr></table></figure>

<p>那这两种方式与 <code>npx</code> 对比，有什么缺点：</p>
<ol>
<li>第一种，命令中的路径过于长，输入命令执行时过于繁琐</li>
<li>第二种，上面也说过全局安装就没办法确保别人也安装了，同时容易出现版本不一致的问题</li>
</ol>
<p>了解完毕！我们回到交互式配置文件生成，执行完上述命令后命令行就会询问下面的问题，关于每一个问题的详细说明，大家感兴趣可以看一下这篇文章 <a href="https://dev.to/devdammak/setting-up-eslint-in-your-javascript-project-with-vs-code-2amf">Setting up ESLINT in your JavaScript Project with VS Code</a>:</p>
<ul>
<li><p>How would you like to use ESLint?</p>
<p>我们选择第三条：<code>To check syntax, find problems, and enforce code style</code>，用于检查语法、检查问题代码并强制代码风格</p>
</li>
<li><p>What type of modules does your project use?</p>
<p>项目非配置代码都是采用的 ES6 模块系统导入导出，选择 <code>JavaScript modules (import/export) </code></p>
</li>
<li><p>Which framework does your project use?</p>
<p>显然，我们需要选择 <code>react</code></p>
</li>
<li><p>Does your project use TypeScript?</p>
<p>同样的毫无疑问的选择 <code>Yes</code>，这样 eslint 的配置文件会给我们默认添加上支持 TypeScript 的 <code>parse</code> 以及插件 <code>plugins</code> 等</p>
</li>
<li><p>Where does your code run?</p>
<p><code>Browser</code> 和 <code>Node</code> 环境都选上，因为我们后面可能会编写一些 node 代码</p>
</li>
<li><p>How would you like to define a style for your project?</p>
<p>选择 <code>Use a popular style guide</code>，即使用社区已经制定好的代码风格，我们去遵守就行</p>
</li>
<li><p>Which style guide do you want to follow?</p>
<p>选择 <code>Airbnb</code> （爱彼迎）风格，都是社区里总结出来的最佳实践</p>
</li>
<li><p>What format do you want your config file to be in?</p>
<p>选择 <code>JavaScript</code>，即生成的配置文件是 js 文件，配置更加灵活，虽然灵活。但是 js 格式没办法使用 VSCode 提供的 JSON Validate 功能</p>
</li>
<li><p>Would you like to install them now with npm?</p>
<p>选择 <code>Yes</code></p>
</li>
</ul>
<p>经过漫长安装后，我猜你的项目根目录应该会长出了新的文件 <code>.eslintrc.js</code>，这便是 eslint 的配置文件了。其么默认的内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es2021: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&quot;plugin:react/recommended&quot;</span>, <span class="string">&quot;airbnb&quot;</span>],</span><br><span class="line">  parser: <span class="string">&quot;@typescript-eslint/parser&quot;</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      jsx: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ecmaVersion: <span class="number">12</span>,</span><br><span class="line">    sourceType: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="string">&quot;react&quot;</span>, <span class="string">&quot;@typescript-eslint&quot;</span>],</span><br><span class="line">  rules: &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到相对于非 TypeScript 项目，使用 <code>@typescript-eslint/parser</code> 替换掉了默认的 parse，并添加了 <code>@typescript-eslint</code> 插件。而配置中的各个属性字段的作用大家可以在 <a href="https://eslint.bootcss.com/docs/user-guide/configuring">Configuring ESLint</a> 中详细了解，可能会对 <code>extends</code> 和 <code>plugins</code> 的关系产生疑惑，其实 <code>plugins</code> 就是插件的意思，都是需要 npm 包的安装才可以使用，只不过这里支持简写，所以看不出来而已。而 <code>extends</code> 就是已经下载的插件的某些预设规则。</p>
<p>现在我们对该配置文件作以下修改：</p>
<ul>
<li><p>根据 <a href="https://www.npmjs.com/package/eslint-config-airbnb">eslint-config-airbnb</a> 的官方说明，如果要开启 React Hooks 的检查，需要在 <code>extends</code> 属性中添加一项 <code>airbnb/hooks</code></p>
</li>
<li><p>根据 <a href="https://www.npmjs.com/package/@typescript-eslint/eslint-plugin">@typescript-eslint/eslint-plugin</a> 的官方说明，在 <code>extends</code> 属性中添加<br><code>plugin:@typescript-eslint/recommended</code> 可以开启针对 TypeScript 的语法推荐的规则定义</p>
</li>
<li><p>为了让 <code>eslint-plugin-import</code> 能够正确解析 <code>ts</code> <code>tsx</code> <code>json</code> 等后缀名。我们还需要指定允许的后缀名，添加 <code>settings</code> 属性，加入以下配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">settings: &#123;</span><br><span class="line">  <span class="string">&#x27;import/reslover&#x27;</span>: &#123;</span><br><span class="line">    node: &#123;</span><br><span class="line">      <span class="comment">// 指定eslint-plugin-import解析的后缀名，出现频率高的文件类型放在前面</span></span><br><span class="line">      extensions: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为目前 <code>eslint-plugin-import</code> 与 TypeScript 搭配存在 Bug，需要添加一条很重要的 <code>rule</code>，不然在 <code>.ts</code> 和 <code>.tsx</code> 模块文件中引入另一个模块会报错，添加以下规则到 <code>rules</code> 即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eslint-plugin-import和typescript搭配不能正确处理后缀名bug</span></span><br><span class="line">rules: &#123;</span><br><span class="line">  <span class="string">&#x27;import/extensions&#x27;</span>: [</span><br><span class="line">    ERROR,</span><br><span class="line">    <span class="string">&#x27;ignorePackage&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      ts: <span class="string">&#x27;never&#x27;</span>,</span><br><span class="line">      tsx: <span class="string">&#x27;never&#x27;</span>,</span><br><span class="line">      json: <span class="string">&#x27;never&#x27;</span>,</span><br><span class="line">      js: <span class="string">&#x27;never&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>接下来安装 3 个社区中比较优秀的 eslint 插件：</p>
<ol>
<li><code>eslint-plugin-promise</code> 可以帮助你把 Promise 语法写成最佳实践</li>
<li><code>eslint-plugin-unicorn</code> 提供了循环依赖检测，文件名大小写风格约束等非常使用的规则集合</li>
<li><code>eslint-plugin-eslint-comments</code> 用于检测出无用的 <code>eslint-disable</code> 注释</li>
</ol>
<p>执行以下命令进行安装上面 3 个 eslint 插件依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D eslint-plugin-promise eslint-plugin-unicorn eslint-plugin-eslint-comments</span><br></pre></td></tr></table></figure>

<p>配置文件在作了部分修改后，现在配置文件的内容长这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OFF = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> WARN = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ERROR = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es2021: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">&quot;airbnb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;airbnb/hooks&quot;</span>,</span><br><span class="line">    <span class="string">&quot;plugin:eslint-comments/recommended&quot;</span>,</span><br><span class="line">    <span class="string">&quot;plugin:react/recommended&quot;</span>,</span><br><span class="line">    <span class="string">&quot;plugin:unicorn/recommended&quot;</span>,</span><br><span class="line">    <span class="string">&quot;plugin:promise/recommended&quot;</span>,</span><br><span class="line">    <span class="string">&quot;plugin:@typescript-eslint/recommended&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  parser: <span class="string">&quot;@typescript-eslint/parser&quot;</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      jsx: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ecmaVersion: <span class="number">12</span>,</span><br><span class="line">    sourceType: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  settings: &#123;</span><br><span class="line">    <span class="string">&quot;import/resolver&quot;</span>: &#123;</span><br><span class="line">      node: &#123;</span><br><span class="line">        <span class="comment">// 指定eslint-plugin-import解析的后缀名，出现频率高的文件类型放在前面</span></span><br><span class="line">        extensions: [<span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.tsx&quot;</span>, <span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="string">&quot;react&quot;</span>, <span class="string">&quot;unicorn&quot;</span>, <span class="string">&quot;promise&quot;</span>, <span class="string">&quot;@typescript-eslint&quot;</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// eslint-plugin-import和typescript搭配不能正确处理后缀名bug</span></span><br><span class="line">    <span class="string">&quot;import/extensions&quot;</span>: [</span><br><span class="line">      ERROR,</span><br><span class="line">      <span class="string">&quot;ignorePackages&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        ts: <span class="string">&quot;never&quot;</span>,</span><br><span class="line">        tsx: <span class="string">&quot;never&quot;</span>,</span><br><span class="line">        json: <span class="string">&quot;never&quot;</span>,</span><br><span class="line">        js: <span class="string">&quot;never&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然这还没完，在后面的配置过程中，我们还需要对 <code>.eslintrc.js</code> 配置文件进行更改。比如还要解决 eslint 和 pittier 规则冲突等问题，所以在这里先卖个关子。</p>
</blockquote>
<p>此时我们就新建一个 <code>hello.ts</code> 文件，在文件内敲入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> add;</span><br></pre></td></tr></table></figure>

<p>此时你应该会发现没有任何的错误提示，很明显代码里使用了违反规则的变量定义符号 <code>var</code>，理论上来说 eslint 应该要报错，但没有报错。我们可以通过 OUTPUT 窗口得知，其实是因为 <code>@typescript-eslint/eslint-plugin</code> 这个插件需要我们安装 TypeScript 依赖，</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201127132331.png" alt="缺少typescript依赖"></p>
<p>虽然 TypeScript 部分的内容应该在后面才开始讲。但是为了 eslint 插件现在能够正常工作，我们就先执行以下命令安装 TypeScript 依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D typescipt</span><br></pre></td></tr></table></figure>

<p>安装完之后，再回头看看 <code>hello.ts</code> 文件的内容，就一堆红色波浪线了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201127133702.png" alt="eslint生效"></p>
<p>其实安装 ESLint VSCode 插件后，是能够支持自动修复功能的，所以我们安装 <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a> 插件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201127134336.png" alt="ESLint插件"></p>
<p>然后我们到先前创建的 <code>.vscode/settings.json</code> 配置文件中添加以下配置信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;eslint.validate&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    <span class="string">&quot;javascriptreact&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescript&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescriptreact&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 代替VSCode的TS语法只能提示</span></span><br><span class="line">  <span class="attr">&quot;typescript.tsdk&quot;</span>: <span class="string">&quot;./node_modules/typescript/lib&quot;</span>,</span><br><span class="line">  <span class="comment">// 保存时，自动进行一次eslint代码修复</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们回到 <code>hello.ts</code> 中，保存文件时，VSCode 就会通知 ESLint，而 ESLint 插件就会根据 <code>.eslintrc.js</code> 配置文件中的配置信息来修复问题代码，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201127141242.gif" alt="ESLint保存时修复问题代码"></p>
<p>不过有时候我们并不希望 ESLint 或 Prettier 对某些文件作任何修改，比如某个特定的情况下我想去看看打包后的内容。但是打包后的内容肯定不符合各种 lint 规则，但我又不希望在按下保存时对其进行修复，此时就需要我们创建两个配置文件 <code>.eslintignore</code> 和 <code>.prettierignore</code>，一般会保持这两个配置文件的内容一致，内容如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/node_modules</span><br><span class="line">/build</span><br><span class="line">/dist</span><br></pre></td></tr></table></figure>

<p>我们先添加以上三个比较常见的文件夹做忽略就好了，后续可以视情况添加更多需要忽略的文件或文件夹。</p>
<h3 id="4-StyleLint"><a href="#4-StyleLint" class="headerlink" title="4. StyleLint"></a>4. StyleLint</h3><p>经过上面猛如虎的操作，项目里的 JS 或者 TS 代码已经能够保持较好的代码风格和代码规范了。但是除了他们两个，还有样式代码的代码规范要统一。这个的确很有必要，毕竟做事要做全套！</p>
<p>根据 <a href="https://stylelint.io/user-guide/get-started">stylelint 官网介绍</a>，我们需要先执行以下命令安装两个依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D stylelint stylelint-config-standard</span><br></pre></td></tr></table></figure>

<p>然后再项目根目录新建 <code>.stylelintrc</code> 配置文件，输入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&quot;stylelint-config-standard&quot;</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">&quot;comment-empty-line-before&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;declaration-empty-line-before&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;function-name-case&quot;</span>: <span class="string">&quot;lower&quot;</span>,</span><br><span class="line">    <span class="string">&quot;no-descending-specificity&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;no-invalid-double-slash-comments&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ignoreFiles: [<span class="string">&quot;node_modules/**/*&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，简单介绍一下配上信息里的三个属性：</p>
<ul>
<li>extend：其实和 eslint 配置里的类似，都是扩展，使用 stylelint 已经预设好的一些规则</li>
<li>rules：就是具体的规则，如果对默认的规则不满意，可以自己做具体的修改</li>
<li>ignoreFiles：与 eslint 需要单独创建 ignore 配置文件不同，stylelint 配置文件里就支持忽略的属性字段。这里我们先添加 <code>node_modules</code> 和 <code>build</code>，后面视情况再做添加</li>
</ul>
<blockquote>
<p>其中关于 xxx/**/* 这种写法感兴趣的，可以 Google 一下：<a href="https://www.google.com/search?q=glob%E6%A8%A1%E5%BC%8F">glob 模式</a></p>
</blockquote>
<p>和 eslint 一样，想要在编辑代码时有错误提示和自动修复功能，就需要 stylelint VSCode 插件<br>，所以我们安装 <a href="https://marketplace.visualstudio.com/items?itemName=stylelint.vscode-stylelint">stylelint</a> 插件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201127145516.png" alt="stylelint插件"></p>
<p>安装完后，我们对先前的 <code>.vscode/settings.json</code> 配置文件，添加以下代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 保存时，自动进行一次代码风格格式化</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 保存时，自动进行一次eslint和styleline代码修复</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;source.fixAll.stylelint&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 使用stylelint自身的校验即可</span></span><br><span class="line">  <span class="attr">&quot;css.validate&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;less.validate&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;scss.validate&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们随便创建一个 <code>.less</code> 文件，测试一下刚刚的配置是否生效。可以看到在样式代码文件里，已经有错误提示和保存时的自动修复问题代码的功能了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201127150647.gif" alt="stylelint保存时自动修复问题代码"></p>
<p>现在我们可以再下载社区里一些比较优秀的 stylelint 扩展和插件：</p>
<ul>
<li><code>stylelint-config-rational-order</code> 用于规范我们在书写样式属性时，按照以下的属性类型顺序来排序</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Positioning</span><br><span class="line">Box Modal</span><br><span class="line">Typography</span><br><span class="line">Visual</span><br><span class="line">Anumation</span><br><span class="line">Misc</span><br></pre></td></tr></table></figure>

<ul>
<li><code>stylelint-declaration-block-no-ignored-properties</code> 用于提示我们写出的矛盾样式，比如下面 <code>css</code> 代码中的 <code>width</code> 属性是会被浏览器忽略，这样可以避免我们犯一些书写样式时的低级错误</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来执行以下命令安装一波依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D stylelint-order stylelint-config-rational-order stylelint-declaration-block-no-ignored-properties</span><br></pre></td></tr></table></figure>

<p>安装完后，我们把 <code>.stylelintrc.js</code> 配置文件修改成以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&quot;stylelint-config-standard&quot;</span>, <span class="string">&quot;stylelint-config-rational-order&quot;</span>],</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">&quot;stylelint-order&quot;</span>,</span><br><span class="line">    <span class="string">&quot;stylelint-declaration-block-no-ignored-properties&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">&quot;plugin/declaration-block-no-ignored-properties&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;comment-empty-line-before&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;declaration-empty-line-before&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;function-name-case&quot;</span>: <span class="string">&quot;lower&quot;</span>,</span><br><span class="line">    <span class="string">&quot;no-descending-specificity&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;no-invalid-double-slash-comments&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ignoreFiles: [<span class="string">&quot;node_modules/**/*&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此，关于 stylelint 的相关配置就暂告一段落啦！其实以上关于 stylelint 所配置的信息都是参考 <a href="https://github.com/ant-design/ant-design/blob/master/.stylelintrc.json">ant-design 的 stylelint 配置文件</a>来进行配置的。但是，对于具体的规则以及插件大家都可以在其官网浏览查找，然后添加自己想要的规则定义。</p>
<h3 id="5-命令行中的-lint"><a href="#5-命令行中的-lint" class="headerlink" title="5. 命令行中的 lint"></a>5. 命令行中的 lint</h3><p>在上面篇幅中，我们都是以 VSCode 插件的形式来使用到 lint，也提到过 lint 可以使用 lint 命令行工具所提供的命令来规范化我们的代码。当然 prettier 也能够通过 prettier 命令行工具所提供的命令来格式化我们的代码。</p>
<p>我们在项目配置文件 <code>package.json</code> 中的 <code>scripts</code> 属性添加以下配置信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;npm run lint-eslint &amp;&amp; npm run lint-stylelint&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint-eslint&quot;</span>: <span class="string">&quot;eslint -c .eslintrc.js --ext .ts,.tsx,.js src&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint-stylelint&quot;</span>: <span class="string">&quot;stylelint --config .stylelintrc.js src/**/*.&#123;less,scss,css&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们在控制台的命令行界面中执行 <code>npm run lint-eslint</code> 时，eslint 就会以 <code>.eslintrc.js</code> 配置文件里配置的代码规范， 到 <code>src</code> 文件夹下对指定后缀的代码文件内容进行检测，而 <code>npm run lint-stylelint</code> 也是类似原理。执行 <code>npm run lint</code> 的话会按顺序合并执行前两个指令。</p>
<p>我估计有小伙伴就会问，前面都已经在 <code>.vscode/settings.json</code> 配置文件里配置了保存代码时自动进行一次代码风格格式化（<code>editor.formatOnSave</code>）和代码规范修复（<code>editor.codeActionsOnSave</code>）了，为啥还需要配置 <code>package.json</code> 里 <code>scripts</code> 属性的 lint 命令？其实，这是为了提供给后面章节中提到的 lint-staged 使用的，而 lint-staged 是什么？跟着我继续走，很快你就会知道了！</p>
<h3 id="6-解决-lint-与-Prettier-的冲突"><a href="#6-解决-lint-与-Prettier-的冲突" class="headerlink" title="6. 解决 lint 与 Prettier 的冲突"></a>6. 解决 lint 与 Prettier 的冲突</h3><p>前面在 ESLint 小节开头里也说了， 虽然 lint 工具有一定的格式化代码的能力，但是其主要功能并不是负责格式化代码，所以格式化代码的工作就交由前面两个专门进行代码风格格式化的工具进行处理了。所以有时候 eslint 和 stylelint 的格式化规则会与 prettier 的格式化规则产生冲突，比如在配置文件 <code>.eslintrc.js</code> 中属性 <code>extends</code> 中的配置设置了缩进为 4，但是在配置文件 <code>.prettierrc</code> 中设置了缩进为 2，那就会出现保存时，先是 eslint 自定修复缩进为 4，然后 prettier 又不开心的把缩进改为 2，然后 eslint 也不开心，直接报错！</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201127162605.gif" alt="ESLint与Prettier冲突"></p>
<p>那已经冲突了，我们要如何解决呢？其实官方已经提供了很好的解决方案，在查阅 Prettier 官网文档中的 <a href="https://prettier.io/docs/en/integrating-with-linters.html">Integrating with Linters</a> 章节可知，针对 eslint 和 stylelint 都有相应的插件支持解决该类问题，其原理基本都是禁用其与 prettier 发生冲突的规则，从而达到解决冲突的效果。</p>
<h4 id="1-解决-ESLint-与-Prettier-的冲突"><a href="#1-解决-ESLint-与-Prettier-的冲突" class="headerlink" title="1. 解决 ESLint 与 Prettier 的冲突"></a>1. 解决 ESLint 与 Prettier 的冲突</h4><p>执行以下命令安装 <a href="https://github.com/prettier/eslint-config-prettier">eslint-config-prettier</a> ，这样就可以禁用 eslint 中所有和 prettier 产生冲突的规则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D eslint-config-prettier</span><br></pre></td></tr></table></figure>

<p>安装完后，再到 <code>.eslintrc.js</code> 配置文件的 <code>extends</code> 属性中，添加以下配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&#x27;prettier&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;prettier/react&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;prettier/unicorn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;prettier/@typescript-eslint&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意，<strong>新增的配置信息需要放在原来 <code>extends</code> 属性配置信息的最后面</strong>，这样才能覆盖掉冲突的规则。</p>
<h4 id="2-解决-Stylelint-与-Prettier-的冲突"><a href="#2-解决-Stylelint-与-Prettier-的冲突" class="headerlink" title="2. 解决 Stylelint 与 Prettier 的冲突"></a>2. 解决 Stylelint 与 Prettier 的冲突</h4><p>Stylelint 与 Prettier 的冲突解决方法是与 ESLint 的解决方法一样的，先执行以下命令安装 <a href="https://github.com/prettier/stylelint-config-prettier">stylelint-config-prettier</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D stylelint-config-prettier</span><br></pre></td></tr></table></figure>

<p>安装完后，再到 <code>.stylelintrc.js</code> 配置文件的 <code>extends</code> 属性中，添加以下配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&#x27;stylelint-config-prettier&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样要注意，<strong>新增的配置信息需要放在原来 <code>extends</code> 属性配置信息的最后面</strong>，这样才能覆盖掉冲突的规则。</p>
<h3 id="7-lint-staged"><a href="#7-lint-staged" class="headerlink" title="7. lint-staged"></a>7. lint-staged</h3><p>我们前面已经成功的让代码在保存时，就自动的格式化并规范化所编写的代码，乍一看，好像是挺完美了！但是，其实在 commit 代码文件到 git 时，是可能会有漏网之鱼的。那有没有一种办法就是在代码 <code>git commit</code> 前帮我们把 git stage 区（暂存区）的代码文件，再进行一次格式化和规范化？</p>
<p>答案，是有的，而且还有俩：</p>
<ol>
<li><a href="https://github.com/azz/pretty-quick">pretty-quick</a></li>
<li><a href="https://github.com/okonet/lint-staged">lint-staged</a></li>
</ol>
<p>不过我们这里选择使用 lint-staged，因为 pretty-quick 功能比较单一，只是提供了 prettier 格式化 stage 区代码的功能，没办法配合 eslint 和 stylelint 一同使用，而且还不能通过配置文件来加以配置。而 lint-staged 就更加灵活，通过他我们可以同时配合 eslint, stylelint, prettier 一起使用，正可谓一个字，爽！</p>
<p>为了达到在我们每次 <code>git commit</code> 前，都自动的格式化和规范化代码，我们需要给 git 命令配置钩子，使其可以在 commit 前先执行我们的命令。这里我们使用 <a href="https://github.com/typicode/husky">husky</a> 工具就可以很轻松的达到这样的目标。</p>
<p>先执行以下命令安装 husky 和 lint-staged 依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D husky lint-staged</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要注意，已经 <code>git init</code> 初始化过 git 本地仓库后才能安装 husky 依赖包。因为在安装 husky 时 husky 会在 <code>.git\hooks</code> 文件夹里配置 git 的钩子脚本，如果还未初始化 git 本地仓库就没有 <code>.git\hooks</code> 文件夹，就会导致 husky 配置钩子脚本失败。但是你已经不幸的先安装 husky 了，那么可以先执行 <code>npm uninstall -D husky</code> 卸载已经安装了的 husky 依赖包，然后再来初始化本地 git 仓库后，执行上面的脚本重新安装 husky 即可。</p>
</blockquote>
<p>随后，回到 package.json 配置文件，添加以下代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;*.&#123;ts,tsx,js&#125;&quot;</span>: [<span class="string">&quot;eslint -c .eslintrc.js&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;*.&#123;less,scss,css&#125;&quot;</span>: [<span class="string">&quot;stylelint --config .stylelintrc.js&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;*.&#123;ts,tsx,js,json,html,yml,less,scss,css,md&#125;&quot;</span>: [<span class="string">&quot;prettier --write&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的配置大概的意思是，在我们 <code>git commit</code> 后，会先对 git stage 区中后缀为 <code>.ts</code> <code>.tsx</code> <code>.js</code> 的文件进行 eslint 规范校验，<code>--config</code> 的作用是指定配置文件。之后的同理，也是对后缀为 <code>.less</code> <code>.scss</code> <code>.css</code> 的文件进行 stylelint 校验。需要注意的是，我们在这里并没有添加 <code>--fix</code> 来进行自动修复不符合规则的代码，因为 lint 出的代码问题，可能涉及到具体语法层面的东西，所以需要我们人为判断才能进行修复，否则很容易出现问题。</p>
<p>但是对于 prettier 的话，由于其格式化不涉及具体语法层面的东西，所以我们使用 <code>--write</code> 来格式化所有符合后缀匹配文件里的内容。</p>
<blockquote>
<p>另外，可能大家看到一些教程或者项目里头，会发现他们配置 lint-staged 还加了 git add 命令，实际上 lint-staged 在 V10 版本开始，任何被修改了的原 staged 区的文件都会自动被 git add。所以，我们不需要再自己配置上 git add 命令了。</p>
</blockquote>
<h2 id="统一代码提交规范配置"><a href="#统一代码提交规范配置" class="headerlink" title="统一代码提交规范配置"></a>统一代码提交规范配置</h2><p>在多人协作的项目中，如果 git 的提交说明足够清晰准确，那么在后期协作以及 bug 处理时就会变得有据可查。并且还可以根据规范的提交说明快速生成开发日志，从而方便开发者或者用户追踪项目的开发信息和功能特性。建议大家阅读 <a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南（阮一峰）</a></p>
<h3 id="1-commitlint"><a href="#1-commitlint" class="headerlink" title="1. commitlint"></a>1. commitlint</h3><p><a href="https://github.com/conventional-changelog/commitlint">commitlint</a> 可以帮助我们在执行 <code>git commit -m &quot;message&quot;</code> 时，对 <code>&quot;message&quot;</code> 进行格式规范的检查。而 commitlint 有一个扩展 <a href="https://github.com/conventional-changelog/commitlint">conventinal-changelog</a> 可以帮助我们根据格式规范化后的 git message 快速生成 changelog。另外还有一个支持在命令行中进行可视化 <code>git commit</code> 的插件 <a href="https://github.com/commitizen/cz-cli">commitizen</a>，但我们这里就不进行配置了，感兴趣的同学可以自行了解。</p>
<p>首先执行以下命令，安装 commitlint 相关依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @commitlint/cli @commlint/config-conventional</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/conventional-changelog/commitlint/tree/master/@commitlint/config-conventional">@commitlint/config-conventional</a> 类似 <code>.eslintrc.js</code> 配置文件中 <code>extends</code> 属性的扩展，他是官方推荐的 angular 风格的 commitlint 配置，提供了一些对于 commint message 的 lint 规则。</p>
<p>他默认支持的提交类型有以下这几个：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&quot;build&quot;</span>, <span class="comment">// 改变了build 工具，如：webpack</span></span><br><span class="line">  <span class="string">&quot;ci&quot;</span>, <span class="comment">// 持续集成的相关变更</span></span><br><span class="line">  <span class="string">&quot;chore&quot;</span>, <span class="comment">// 构建过程或辅助工具的变动</span></span><br><span class="line">  <span class="string">&quot;docs&quot;</span>, <span class="comment">// 文档变更</span></span><br><span class="line">  <span class="string">&quot;feat&quot;</span>, <span class="comment">// 新功能</span></span><br><span class="line">  <span class="string">&quot;fix&quot;</span>, <span class="comment">// 修复Bug</span></span><br><span class="line">  <span class="string">&quot;perf&quot;</span>, <span class="comment">// 性能优化</span></span><br><span class="line">  <span class="string">&quot;rafactor&quot;</span>, <span class="comment">// 某个功能重构</span></span><br><span class="line">  <span class="string">&quot;revert&quot;</span>, <span class="comment">// 撤销上一次commit</span></span><br><span class="line">  <span class="string">&quot;style&quot;</span>, <span class="comment">// 样式代码变更</span></span><br><span class="line">  <span class="string">&quot;test&quot;</span> <span class="comment">// 自动化测试变更</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我们在项目根目录创建配置文件 <code>.commitlintrc.js</code>，这就是我们的 commitlint 配置文件，配置以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&quot;@commitlint/config-conventional&quot;</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">&quot;type-enum&quot;</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">&quot;always&quot;</span>,</span><br><span class="line">      <span class="comment">// 比默认值多了一个 deps，用于表示依赖增、删、改等提交</span></span><br><span class="line">      [</span><br><span class="line">        <span class="string">&quot;build&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ci&quot;</span>,</span><br><span class="line">        <span class="string">&quot;chore&quot;</span>,</span><br><span class="line">        <span class="string">&quot;deps&quot;</span>,</span><br><span class="line">        <span class="string">&quot;docs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;feat&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fix&quot;</span>,</span><br><span class="line">        <span class="string">&quot;perf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;refactor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;revert&quot;</span>,</span><br><span class="line">        <span class="string">&quot;style&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test&quot;</span>,</span><br><span class="line">      ],</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，我们回到 <code>package.json</code> 配置文件，在 <code>husky</code> 属性里增加一个用于执行 commitlint 的 git 的钩子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;commit-msg&quot;</span>: <span class="string">&quot;commitlint --config .commitlintrc.js -E HUSKY_GIT_PARAMS&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用 <code>git commit -m &quot;message&quot;</code> 时，git 的 <code>commit-msg</code> 钩子就会把保存 commit message 的文件路径临时赋给环境变量 <code>HUSKY_GIT_PARAMS</code>，然后 <code>commitlint</code> 就会去 lint 这个文件中的 commit message。</p>
<p>我们接着再配置自动生成 changelog，执行以下命令安装 conventional-changelog-cli 依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D conventional-changelog-cli</span><br></pre></td></tr></table></figure>

<p>再回到 <code>package.json</code> 配置文件，在 <code>scripts</code> 属性里配置多一个新的命令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;changelog&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在命令行中通过 <code>npm run changelog</code> 来生成 angular 风格的 changelog 了，<code>conventional-changelog</code> 会读取提交历史中 type 为 <code>fix</code> <code>feat</code> 等的 commit message 自动生成 changelog。</p>
<p>现在就来测试一下我们上面所配置的，有没有如预期一样正常运行吧！我们执行以下不规范的 commit message 命令进行提交变更（规范的 commit message ，其 type 应为 chore，所以应该 commitlint 应该会报错）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交所有变更文件到暂存区</span></span><br><span class="line">git add -A</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区的所有变更文件提交到分支</span></span><br><span class="line">git commit -m &quot;chora: add commitlint to force commit style&quot;</span><br></pre></td></tr></table></figure>

<p>如预期那样，出现了如下图的报错：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201129013626.png" alt="commitlint报错"></p>
<p>那我们把 commit message 中的 type 进行更正，就能成功 commit 啦！更正后的 commit 脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;chore: add commitlint to force commit style&quot;</span><br></pre></td></tr></table></figure>

<p>这时我们就成功的 commit，然后再执行以下命令就能把变更提交到远端的 git 版本管理服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>呼，经历了那么漫长的配置之路，我们终于搭建了一个较为完善的项目开发环境。前面这些只是餐前小菜，而接下来才是真正的正菜，我们需要开始在当前这个环境之上把 Webpack 相关的东西加进来，搭建起真正可以进行项目开发的环境，是不是有点期待？那就带着期待一起往下走吧！</p>
<h2 id="Webpack-基本配置"><a href="#Webpack-基本配置" class="headerlink" title="Webpack 基本配置"></a>Webpack 基本配置</h2><p>相信看到这里的你，应该是把上面的章节都实践了一遍。如果没有的话，也没有关系！因为下文的内容，其实也可以做为以 Webpack 为构建打包工具，搭建起项目开发环境的一个参考。你可以参考其中使用到的配置，了解其在整个项目环境流程中起到的作用并加深记忆，还可以考虑是否能把他们配置到你现有的开发环境里。</p>
<p>对于 Webpack 的基本配置，都会尽可能的以详细解释和具体操作去把所有产生的问题全部打破，希望大家还是能够耐心阅读！</p>
<blockquote>
<p>请注意，下文中的：Webpack 版本为 4+ ，Webapck CLI 版本为：3+，Webpack Dev Server 版本为 3+</p>
</blockquote>
<h3 id="1-事前准备"><a href="#1-事前准备" class="headerlink" title="1. 事前准备"></a>1. 事前准备</h3><p>想要使用 Webpack，那就得执行以下命令安装两个关于 Webpack 的项目开发依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 限定安装大版本为4的Webapck，和大版本为3的Webapck CLI</span></span><br><span class="line">npm i -D webpack@4 webpack-cli@3</span><br></pre></td></tr></table></figure>

<ul>
<li>webpack：这个应该不用多做解释，前端项目常用的项目构建打包工具</li>
<li>webpack-cli：此依赖包是 Webpack 的命令行工具，用于在命令行中使用 Webpack</li>
</ul>
<p>接着我们在项目根目录下创建一个新的文件夹 <code>scripts</code>，在文件夹内再创建一个文件夹 <code>config</code>，在 <code>config</code> 文件夹里头创建一个 <code>.js</code> 文件 <code>webpack.common.js</code>，此时目录结构应该如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">scripts/</span><br><span class="line">  config/</span><br><span class="line">  webpack.common.js</span><br></pre></td></tr></table></figure>

<p>这样设计目录结构的原因是，我们会分为开发构建环境和生产构建环境，而这两个构建环境所使用的 Webpack 脚本中的配置有相同的部分也有不相同的部分，相同的部分我们一般都放在所创建的 <code>webpack.common.js</code> 通用构建打包配置文件内，不同的部分就另外分别创建两个环境的构建打包配置文件。然后后续会把这两个环境的配置文件和通用配置文件中的配置信息通过 <code>webapck-merge</code> 依赖包进行合并处理。</p>
<h3 id="2-配置-input-output"><a href="#2-配置-input-output" class="headerlink" title="2. 配置 input, output"></a>2. 配置 input, output</h3><p><strong>input（入口）和 output（出口）</strong>是 Webpack 的核心概念之一，顾名思义就大概能猜到他们是用来干嘛的，入口就是给 Webpack 指定一个或多个构建打包的入口及其对应的出口，Webpack 经过一系列的构建操作打包操作后就把产出物输出到对应的出口中。（注：可以多个出口 js 文件对应一个 html 模板，也可以多个出口 js 文件对应多个 html 模板，需要通过 Webpack 的 <code>html-webpack-plugin</code> 插件配合处理）</p>
<p>接下来在刚创建的通用构建打包配置文件 <code>webpack.common.js</code> 中输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: path.resolve(__dirname, <span class="string">&quot;../../src/app.js&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;js/[name].[hash:8].js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;../../dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Webpack 构建打包配置文件是标准的 Node.js 的 CommonJS 模块，通过 <code>require</code> 来引入其他模块，通过 <code>module.exports</code> 来导出模块，由 Webpack 根据对象定义的属性进行解析。</p>
</blockquote>
<ul>
<li><code>entry</code> 属性定义了入口文件路径，其值支持字符串、数组、对象类型，对象值类型支持定义多入口。而上面以对象类型作为其值，且属性名 <code>app</code> 可用于出口文件名字</li>
<li><code>output</code> 属性定义了构建打包之后的出口文件名及其所在路径</li>
</ul>
<p>这段代码的意思就是告诉 Webpack，入口文件是项目根目录下的 <code>src</code> 文件夹里的 <code>app.js</code> 代码文件。构建打包产出的文件位置为项目根目录下的 <code>dist</code> 文件夹，其中 <code>filename</code> 属性值为 <code>js/[name].[hash:8].js</code> 就表示会在 <code>dist</code> 文件夹内创建一个新的 <code>js</code> 文件夹，并把产出的文件以入口属性名以及带有八位的 hash 值作为文件名输出到 <code>js</code> 文件夹中。</p>
<p>然后我们在根目录创建 <code>src</code> 文件夹，并创建 <code>app.js</code> 代码文件，其内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line">root.innerHTML = <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>现在我们到项目配置文件 <code>package.json</code> 中的 <code>scripts</code> 属性，添加一条 Webpack 的打包命令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --config ./scripts/config/webpack.common.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们尝试执行一下刚刚所添加的打包命令是否有效，输入以下命令执行 Webapck 打包命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>大概一两秒后，就会发现命令行中有结果反馈，并且项目根目录下会多出一个 <code>dist</code> 文件夹，里面的文件和我们在 Webpack 构建打包配置文件中，所配置的预期是一致的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201129205834.png" alt="构建打包结果反馈"></p>
<p>到这里，我们已经初步使用 Webpack 进行了一次简单的构建打包，接下来我们逐步开始拓展其他的配置和进行相应的优化吧！</p>
<h3 id="3-公共变量文件"><a href="#3-公共变量文件" class="headerlink" title="3. 公共变量文件"></a>3. 公共变量文件</h3><p>在上面简单的 Webpack 配置中，我们发现有两个表示路径的代码语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.resolve(__dirname, <span class="string">&quot;../../src/app.js&quot;</span>);</span><br><span class="line">path.resolve(__dirname, <span class="string">&quot;../../dist&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>path.resolve</code> 是 Node.js 路径处理的 api，可以将路径或者路径片段解析成绝对路径</li>
<li><code>___dirname</code> 是 Node.js 提供的一个全局变量，其值总是指向被执行 js 文件的绝对路径。比如我们在 <code>webpack.common.js</code> 配置文件中的代码里使用到了 <code>__dirname</code>，那么他的值就是 <code>webpack.common.js</code> 配置文件的绝对路径，在我电脑上就是：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">H:\Projects\Front\webpack-typescript-react-practice2\scripts\config\webpack.common.js</span><br></pre></td></tr></table></figure>

<p>相信大家也看出来了，这种写法需要不断的 <code>../../</code>，这在文件层级比较深时，很容易出错且有点不优雅。那我们可以换个思路，都从项目根目录开始找所需要的文件路径不就很简单了吗？相当于省略了 <code>../../</code>。</p>
<p>我们在 <code>scripts</code> 文件夹下创建 <code>constants.js</code> 代码文件，用于存放我们的公共常量，在里面定义我们的常量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ModuleResolutionKind &#125; = <span class="built_in">require</span>(<span class="string">&quot;typescript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PROJECT_PATH = path.resolve(__dirname, <span class="string">&quot;../&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> PROJECT_DIRNAME = path.parse(PROJECT_PATH).name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  PROJECT_DIRNAME,</span><br><span class="line">  PROJECT_PATH,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PROJECT_PATH</code> 表示项目的根目录</li>
<li><code>PROJECT_DIRNAME</code> 表示项目目录名称</li>
</ul>
<p>然后我们修改 <code>webpack.common.js</code> 配置文件，修改完后的内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; PROJECT_PATH &#125; = <span class="built_in">require</span>(<span class="string">&quot;../constants&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: path.resolve(PROJECT_PATH, <span class="string">&quot;./src/app.js&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;js/[name].[hash:8].js&quot;</span>,</span><br><span class="line">    path: path.resolve(PROJECT_PATH, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好啦，现在看起来清爽多了，此时可以执行命令 <code>npm run build</code> 验证一下刚刚做的修改是否可用。</p>
<h3 id="4-区分开发和生产构建环境"><a href="#4-区分开发和生产构建环境" class="headerlink" title="4. 区分开发和生产构建环境"></a>4. 区分开发和生产构建环境</h3><p>在 Webpack 中针对开发构建环境和生产的构建环境需要分别配置，这样才能适应不同的环境需求。比如，我们在生产构建环境中并不需要启用 dev server 的功能或者构建打包出代码的 <code>.map</code> 文件。又或者说在开发构建环境中，我们并不需要太过苛刻的代码或者文件压缩，此时就需要为两个环境做相应配置。</p>
<p>虽然需要分别配置，但是其实又有挺多基础配置是开发和生产都需要的，那我们不可能写两次关于基础的配置吧？这样就会造成冗余，所以我们把基础的配置写在 <code>webpack.common.js</code> 配置文件中，然后合并配置的问题就交给 <code>webpack-merge</code> 依赖包解决。</p>
<p>执行以下命令安装 <code>webpack-merge</code> 依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-merge</span><br></pre></td></tr></table></figure>

<p>然后在 <code>scripts/config</code> 文件夹下创建配置文件 <code>webpack.dev.js</code> 作为开发构建的配置文件，且内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同样地，在 <code>scripts/config</code> 文件夹创建配置文件 <code>webpack.prod.js</code> 作为生产配置文件，且内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用 <code>require(&#39;webpack-merge&#39;)</code> 时，eslint 报了如下错误：<br>‘webpack-merge’ should be listed in the project’s denpendencies, not devDependencies.<br>此时，我们只需要在 <code>.eslintrc.js</code> 配置文件中的 <code>rules</code> 属性里添加以下规则即可解决：<br><code>&#39;import/no-extraneous-dependencies&#39;: [ERROR, &#123; devDependencies: true &#125;]</code></p>
</blockquote>
<p>虽然已经分开配置，但是在对于公共配置中，还是可能会出现某些配置的某个选项在开发和生产构建环境中需要采用不同的配置，这时候我们就有两种选择：</p>
<ol>
<li>分别在 <code>webpack.dev.js</code> 和 <code>webpack.prod.js</code> 配置文件中各写一遍，<code>webpack.common.js</code> 就不写了</li>
<li>设置一个环境变量，根据这个变量进行判断不同的构建环境，然后把配置写在 <code>webpack.common.js</code> 中</li>
</ol>
<p>显而易见，为了让配置的代码看起来较为优雅，我们还是采用第二种方案。但是非常不幸的是，由于不同操作系统设置环境变量的方式都各不相同，所以这就造成了一些麻烦。比如，</p>
<ul>
<li>Mac 中需要通过 <code>export NODE_ENV=development</code> 来设置环境变量</li>
<li>Windows 中需要通过 <code>set NODE_ENV=development</code> 来设置环境变量</li>
</ul>
<p>而 <a href="https://www.npmjs.com/package/cross-env">cross-env</a> 是一个可跨平台设置和使用环境变量的 Node.js 命令行依赖包工具，所以有了这个利器，我们就无需考虑操作系统的差异性，统一使用他提供的 api 来进行环境变量的设置啦！</p>
<p>执行以下命令，安装 cross-env 依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D cross-env</span><br></pre></td></tr></table></figure>

<p>然后到 <code>package.json</code> 配置文件中的 <code>scripts</code> 属性里添加以下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line"><span class="addition">+   &quot;start&quot;: &quot;cross-env NODE_ENV=development webpack --config ./scripts/config/webpack.dev.js&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config ./scripts/config/webpack.prod.js&quot;</span></span><br><span class="line"><span class="deletion">-   &quot;build&quot;: &quot;webpack --config ./scripts/config/webpack.common.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>scripts/constants.js</code> 文件，增加一个用于环境判断的布尔变量 <code>ISDEV</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ISDEV = process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ISDEV,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在有了这个环境的判断变量，我们可以用他来做点事情啦！</p>
<p>还记得先前在公共配置中，我们给出口脚本文件的名字生成规则中配置了 <code>[name].[hash:8].js</code>。那为什么要配置上 <code>[hash:8]</code> 呢？我们可以想一下，如果不这么配置，当用户在第一次访问页面时，浏览器根据缓存策略，缓存下了名字为 <code>app.js</code> 的出口脚本文件。然后我们进行了代码修改后，再次使用 Webpack 构建打包，并且发布部署。此时，用户再次访问页面时，浏览器发现本地存在 <code>app.js</code> 脚本文件的缓存，并且该缓存还在有效期内，就直接使用了本地缓存的 <code>app.js</code> 脚本文件。这样就会造成用户无法及时获得脚本文件的更新，最终可能导致用户页面出现异常。</p>
<p>然而加上了<code>[hash:8]</code>之后就不同了，当用户在第一次访问页面时，浏览器根据缓存策略，缓存下了名字为 <code>app.1a2b3c4d.js</code> 的出口脚本文件。然后当我们进行了代码修改后，再次使用 Webpack 构建打包，并且发布部署。新的出口脚本文件名就会根据 hash 运算（内容摘要）后就进行更新，如 <code>app.5e6f7g8h.js</code>。那么用户再次访问页面时，由于其浏览器只缓存过 <code>app.1a2b3c4d.js</code> 并没有缓存过新的 <code>app.5e6f7g8h.js</code> 脚本出口文件，所以浏览器就会向服务器获取该新的出口脚本文件并再次缓存。</p>
<p>不过，这个 hash 值在开发构建环境中并不需要，所以我们修改 <code>webpack.common.js</code> 配置文件：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- const &#123; PROJECT_PATH &#125; = require(&#x27;../constants&#x27;);</span></span><br><span class="line"><span class="addition">+ const &#123; PROJECT_PATH, ISDEV &#125; = require(&#x27;../constants&#x27;);</span></span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line"><span class="deletion">-   filename: &#x27;js/[name].[hash:8].js&#x27;,</span></span><br><span class="line"><span class="addition">+   filename: `js/[name]$&#123;ISDEV ? &#x27;&#x27; : &#x27;.[hash:8]&#x27;&#125;.js`,</span></span><br><span class="line">    path: path.resolve(PROJECT_PATH, &#x27;./dist&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于 HTTP 文件缓存，欢迎阅读我另外一篇文章 <a href="/2019/08/01/http-cache/">HTTP/前端文件缓存</a></p>
</blockquote>
<h3 id="5-mode"><a href="#5-mode" class="headerlink" title="5. mode"></a>5. mode</h3><p>在我们没有在 Webpack 配置文件里设置 <code>mode</code> 属性时，Webpack 默认地为我们设置了 <code>mode: production</code>，所以我们之前打包后的 js 代码文件里的内容都无法直视。因为在 <code>production</code> 模式下，Webpack 会使用 production 默认的 Webapck 配置去丑化、压缩代码等等。</p>
<p>所以我们要了解，不同模式下 Webpack 其实会为我们开启不同的默认配置，进行着不同的优化，详情可见阅读 Webpack 的官方文档中的 <a href="https://webpack.js.org/configuration/mode/#root">webpack.mode</a> 章节。</p>
<p>然后接下来可以分别执行以下命令，看看分别打包有什么区别，主要感知我们上面所做的是否有效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run start</span><br><span class="line"></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<h3 id="6-本地服务实时查看页面"><a href="#6-本地服务实时查看页面" class="headerlink" title="6. 本地服务实时查看页面"></a>6. 本地服务实时查看页面</h3><p>说了那么多，我们到现在连个页面都看不到，使用过各种脚手架的朋友一定很熟悉 <code>npm run start</code>，他直接开启一个本地服务，然后就弹出浏览器显示出页面。而我们现在执行这个命令却只能简单的打个包，那这可不行，别人有的我们也得有呀！ 别急，我们借助 <a href="">webpack-dev-server</a> 和 <a href="">html-webpack-plugin</a> 这两个依赖包就能实现，执行以下命令安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 限定安装大版本为3的Webapck Dev Server与先前安装的Webpack CLI保持一致</span></span><br><span class="line">npm i -D webpack-dev-server@3 html-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>简单介绍一下两个工具的作用：</p>
<ul>
<li><code>webpack-dev-server</code> 可以在本地开启一个 http 服务，可以指定端口和开启热更新功能。通过简单的配置可以让他与我们的 Webpack 开发构建环境搭配使用</li>
<li><code>html-webpack-plugin</code> 每一个页面一定是要有 html 文件的，而这个插件可以帮助我们把构建打包产出的出口脚本文件自动的引入 html 模板文件中，并把经过处理的 html 模板文件输出到出口文件夹中（毕竟我们不可能每次构建打包都自己把出口脚本文件手动引入 html 模板文件中）</li>
</ul>
<p>现在，我们现在项目根目录创建一个 <code>public</code> 文件夹，里面是用于存放一些公共的静态资源文件，现在我们在里面创建一个 <code>index.html</code> html 模板文件，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webapck TypeScript React Practice<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>html-webpack-plugin</code> 在开发和生产环境我们都需要配置，所以我们打开 <code>webpack.common.js</code> 配置文件，增加以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(PROJECT_PATH, <span class="string">&quot;./public/index.html&quot;</span>),</span><br><span class="line">      filename: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">      cache: <span class="literal">false</span>, <span class="comment">// 防止之后使用v6版本的copy-webpack-plugin时，代码修改一刷新页面为空的问题发生</span></span><br><span class="line">      minify: ISDEV</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : &#123;</span><br><span class="line">            removeAttributeQuotes: <span class="literal">true</span>,</span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">            collapseInlineTagWhitespace: <span class="literal">true</span>,</span><br><span class="line">            removeRedundantAttributes: <span class="literal">true</span>,</span><br><span class="line">            removeScriptTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">            removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span>,</span><br><span class="line">            minifyURLs: <span class="literal">true</span>,</span><br><span class="line">            useShortDoctype: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到配置中，我们以 <code>public/index.html</code> 作为我们的 html 模板文件，并且针对生产构建环境，还对该 html 文件进行了代码压缩、去除注释、去除空格等配置。</p>
<blockquote>
<p>Plugin 是 Webpack 的核心功能之一，他丰富了 Webpack 本身，针对的是 Loader 处理结束后，Webpack 打包的整个过程，他并不直接操作文件，而是基于事件机制工作。他会监听 Webpack 打包过程中的某些节点，执行较为宏观的任务。</p>
</blockquote>
<p>随后，我们到 <code>webpack.dev.js</code> 配置文件中增加本地服务的配置, 如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const &#123; SERVER_HOST, SERVER_PORT &#125; = require(&quot;../constants&quot;);</span></span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="addition">+ devServer: &#123;</span></span><br><span class="line"><span class="addition">+   host: SERVER_HOST, // 指定host，不设置的话默认为localhost</span></span><br><span class="line"><span class="addition">+   port: SERVER_PORT, // 指定端口，不设置的话默认为8080</span></span><br><span class="line"><span class="addition">+   stats: &quot;errors-only&quot;, // 重点仅打印error</span></span><br><span class="line"><span class="addition">+   compress: true, // 是否启用gzip压缩</span></span><br><span class="line"><span class="addition">+   open: true, // 打开默认浏览器</span></span><br><span class="line"><span class="addition">+   hot: true, // 热更新</span></span><br><span class="line"><span class="addition">+ &#125;,</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在上面使用到了 <code>scripts/constants.js</code> 中的两个常量 <code>SERVER_HOST</code> 和 <code>SERVER_PORT</code>，所以我们需要在 <code>constants.js</code> 里定义他们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> SERVER_HOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> SERVER_PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  SERVER_HOST,</span><br><span class="line">  SERVER_PORT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中提高开发幸福度的配置项为：</p>
<ul>
<li><code>hot</code> 这个配置开启后，在搭配后面章节中的其他配置，可以开启开发时的热更新</li>
<li><code>stats</code> 当设置为 <code>error_only</code> 时，命令行中只会打印打错记录，这个配置我个人觉得相当有用。在日常开发中不会被一堆的 warn 记录塞满，比如一些 eslint 的规则提示、编译信息等等</li>
</ul>
<p>现在配置好了关于本地服务的相关配置，我们需要到 <code>package.json</code> 配置文件中修改 <code>start</code> 命令：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line"><span class="addition">+   &quot;start&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config ./scripts/config/webpack.dev.js&quot;,</span></span><br><span class="line"><span class="deletion">-   &quot;start&quot;: &quot;cross-env NODE_ENV=development webpack --config ./scripts/config/webpack.dev.js&quot;,</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后确认一下，我们先前编写的 <code>src/app.js</code> 中的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line">root.innerHTML = <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就是把 html 模板中 id 为 app 的 div 标签内的内容替换为 hello world! 字符串。我们执行以下命令，预览一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">npm run start的缩写形式</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>你会发现会自动打开浏览器，并且浏览器还打开了一个页面，而这个页面就是我们期待的那个页面。屏幕中出现了 hello world!，我们查看控制台，发现 html 文件真的就自动引入了我们使用 Webpack 构建打包后的出口文件 <code>app.js</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201130145235.png" alt="控制台界面"></p>
<p>到这里，我们就已经能利用 webpack-dev-server 开启的本地服务实时的进行页面开发了！当然，这远远还是不够的，我们还是会在后面一步一步继续优化。</p>
<h3 id="7-devtool"><a href="#7-devtool" class="headerlink" title="7. devtool"></a>7. devtool</h3><p>devtool 中的一些设置，可以帮我们将构建打包（编译）后的代码映射回原始的源代码，即我们经常所听到的 sourcemap。如：Webpack, TypeScript, babel, powser-assert 等转换代码的工具都有提供 sourcemap 的功能，否则源代码被压缩、混淆、polyfill 后，就根本就没办法调试定位问题了。</p>
<p>所以 sourcemap 对于开发时调式起到了极其重要的作用，而不同类型的 sourcemap 会明显的影响到构建和重新构建的速度。所以根据环境选择一个合适的配置是非常重要的，可以查看官方文档 <a href="https://webpack.js.org/configuration/devtool/">devtool</a> 章节，了解更多。</p>
<table>
<thead>
<tr>
<th>devtool</th>
<th>构建速度</th>
<th>重新构建速度</th>
<th>生产环境</th>
<th>品质（quality）</th>
</tr>
</thead>
<tbody><tr>
<td>(none)</td>
<td>+++</td>
<td>+++</td>
<td>yes</td>
<td>打包后的代码</td>
</tr>
<tr>
<td>eval</td>
<td>+++</td>
<td>+++</td>
<td>no</td>
<td>生成后的代码</td>
</tr>
<tr>
<td>cheap-eval-source-map</td>
<td>+</td>
<td>++</td>
<td>no</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>cheap-module-eval-source-map</td>
<td>o</td>
<td>++</td>
<td>no</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>-</td>
<td>+</td>
<td>no</td>
<td>原始源代码</td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>+</td>
<td>o</td>
<td>yes</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>o</td>
<td>-</td>
<td>yes</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>inline-cheap-source-map</td>
<td>+</td>
<td>o</td>
<td>no</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>inline-cheap-module-source-map</td>
<td>o</td>
<td>-</td>
<td>no</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>source-map</td>
<td>-</td>
<td>-</td>
<td>yes</td>
<td>原始源代码</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>-</td>
<td>-</td>
<td>no</td>
<td>原始源代码</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>-</td>
<td>-</td>
<td>yes</td>
<td>原始源代码</td>
</tr>
<tr>
<td>nosources-source-map</td>
<td>-</td>
<td>-</td>
<td>ye</td>
<td>无源代码内容</td>
</tr>
</tbody></table>
<blockquote>
<p><code>+++</code> 非常快速，<code>++</code> 快速，<code>+</code> 比较快，<code>o</code> 中等，<code>-</code> 比较慢，<code>--</code> 慢</p>
</blockquote>
<p>考虑到编译速度、调式友好性，我在开发构建环境一般会先泽 <code>cheap-module-eval-source-map</code>，而在生产构建环境则会选择 <code>cheap-module-source-map</code>。<strong>大家也可以故意的写错一些代码，然后使用以上的每个设置看看自己比较能接受哪一种 sourcemap 的类型，再做实际调整。</strong></p>
<p>然后到 <code>webpack.dev.js</code> 配置文件中添加以下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line"><span class="addition">+ devtool: &#x27;cheap-module-eval-source-map&#x27;,</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: SERVER_HOST, // 指定host，不设置的话默认为localhost</span><br><span class="line">    port: SERVER_PORT, // 指定端口，不设置的话默认为8080</span><br><span class="line">    stats: &#x27;errors-only&#x27;, // 重点仅打印error</span><br><span class="line">    compress: true, // 是否启用gzip压缩</span><br><span class="line">    open: true, // 打开默认浏览器</span><br><span class="line">    hot: true, // 热更新</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>到 <code>webpack.prod.js</code> 配置文件中添加以下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  mode: &#x27;production&#x27;,</span><br><span class="line"><span class="addition">+ devtool: &#x27;cheap-module-source-map&#x27;,</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过上面的配置后，我们在本地进行开发时，如果代码出现了错误，那么 Console 界面的错误提示就会精确的告诉我们错误的文件、位置等信息。比如我们在 <code>src/app.js</code> 中的第 5 行故意把代码写错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line">root.innerHTML = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>Console 界面里的错误提示我们，在 <code>app.js</code> 代码文件中的第 5 行代码出错了，具体的错误为 <code>Uncaught TypeError: Assignment to constant variable.</code>，赶紧修复吧！</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201130161300.png" alt="Console界面报错"></p>
<h3 id="8-构建打包前清理-dist-文件夹"><a href="#8-构建打包前清理-dist-文件夹" class="headerlink" title="8. 构建打包前清理 dist 文件夹"></a>8. 构建打包前清理 dist 文件夹</h3><p>好像一切看起来都挺完美了，但是真的完美了吗？如果你已经执行了多次 <code>npm run build</code> 后，就会发现事情并没有那么简单，请看下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201130161920.png" alt="冗余的dist文件夹"></p>
<p>嗯？怎么 <code>dist\js</code> 文件夹下多出了那么多的 <code>app.xxxxxxxx.js</code> 的出口脚本文件，这貌似是因为每次执行 <code>npm run build</code> 后，Webpack 都是直接把产出的东西往里面扔就了事了呀。为了让我们最终构建打包时清除前一次的产出物，我们得想个办法解决这个问题。</p>
<p>既然发现了这个问题，那我们在每次构建打包前，都勤快的手动去清理一下 <code>dist</code> 文件夹内的上一次产出的文件不就好了？当然可以！但是这种勤快是毫无意义的。</p>
<p>我们可以借助 <a href="https://github.com/johnagan/clean-webpack-plugin">clean-webpack-plugin</a> 帮助我们在每次构建打包前处理掉之前的 <code>dist</code> 文件夹，以保证其文件夹内的文件都是最新的产出物。执行以下命令安装依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D clean-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>然后到 <code>webpack.prod.js</code> 配置文件，增加一下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);</span></span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="addition">+ plugins: [new CleanWebpackPlugin()],</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>他不需要你去指定要删除的文件夹位置，他会自动的找到 <code>output</code> 属性中的 <code>path</code> 的值进行清除。现在再执行一下 <code>npm run build</code> 命令，看一下现在 <code>dist</code> 文件夹是不是已经干净了许多？并且还多了我们先前配置的 <code>devtool</code> 的 <code>.map</code> 文件。</p>
<h3 id="9-样式文件处理"><a href="#9-样式文件处理" class="headerlink" title="9. 样式文件处理"></a>9. 样式文件处理</h3><p>如果现在我们在 <code>src/</code> 文件夹下创建一个 <code>app.css</code> 样式文件，给选择器 <code>#app</code> 随便添加一个样式，<code>app.js</code> 代码文件中通过 <code>import &#39;./app.css&#39;</code>，再进行生产构建或者开发构建，Webpack 就会直接报错。因为 Webpack 只认识 <code>.js</code> 的代码模块文件，他不支持直接处理 <code>.css</code> <code>.less</code> <code>.scss</code> 等文件，所以我们需要借助 Webpack 另一个核心的东西，他的名字叫 Loader。</p>
<blockquote>
<p>Loader 用于对模块的源代码进行转换，Loader 可以使你在 <code>import</code> 模块文件时，处理文件内容。因此，Loader 类似于其他构件工具中的“任务（Task）”，并提供了处理前端构建步骤的强大方法。Loader 可以将文件从不同的语言，如 TypeScript 转换为 JavaScript，或将内联图像文件转换为 dataURL。Loader 甚至可以让你在 JavaScript 模块中 <code>import</code> CSS 样式文件，把 CSS 样式文件当做 JavaScript 模块使用。</p>
</blockquote>
<h4 id="1-CSS-样式文件"><a href="#1-CSS-样式文件" class="headerlink" title="1. CSS 样式文件"></a>1. CSS 样式文件</h4><p>处理 <code>.css</code> 样式文件，我们需要安装 <a href="https://github.com/webpack-contrib/style-loader">style-loader</a> 和 <a href="https://github.com/webpack-contrib/css-loader">css-loader</a> 两个 Webpack Loader 依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D style-loader css-loader</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Webpack 构建打包时，当解析到 js 模块中有 <code>import</code> 后缀为 <code>.css</code> 的样式文件时，Webpack 会用 css-loader 去解析这个样式文件，解析过程中若在文件内出现了 <code>@import</code> 等语句就将相应的样式文件引入（所以如果没有 css-loader 的话，Webpack 就没办法处理 <code>import</code> 的 css 样式文件），然后 css-loader 再把整个 css 样式文件内容生成为代码字符串，接着让 style-loader 把生成的代码字符串内容以 style 标签的形式插入到 html 模板的 head 标签里。</p>
</blockquote>
<p>安装完后，我们到 <code>webpack.common.js</code> 配置文件中，加入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123; ... &#125;,</span><br><span class="line">  ouput: &#123; ... &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: ISDEV, <span class="comment">// 开启后与devtool设置一致</span></span><br><span class="line">              importLoaders: <span class="number">0</span> <span class="comment">// 指定在css-loader处理前使用的loader数量</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ ... ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单的对以上配置做下介绍：</p>
<ul>
<li><code>test</code> 字段是匹配文件后缀类型正则表达式，针对符合规则的文件进行所配置的 Loader 处理</li>
<li><code>use</code> 属性的值有几种写法<ul>
<li>字符串：例如我们只使用 style-loader 的话，那就可以写成 <code>use: &#39;style-loader&#39;</code></li>
<li>数组：例如我们不对 css-loader 做 <code>options</code> 参数配置，那就可以写成 <code>use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</code>。若需要对某个 Loader 做参数配置可以参考上面的配置</li>
<li>对象：例如只使用 css-loader 的话且需要进行 <code>options</code> 参数配置，那就可以写成 <code>use: &#123; loader: &#39;css-loader&#39;, options: &#123; importLoaders: 0 &#125; &#125;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>Loader 是有顺序的，Webpack 肯定是先将 css 模块依赖解析完得到 css 代码字符串，才能把 css 代码字符串内容以 style 标签的形式插入到 html 模板的 head 标签中。<br>所以在上面的配置中 style-loader 放在了 css-loader 的前面，也就说明了<strong>Webpack Loader 的执行顺序是从右到左，从下到上</strong>的。</p>
</blockquote>
<h4 id="2-less-样式文件"><a href="#2-less-样式文件" class="headerlink" title="2. less 样式文件"></a>2. less 样式文件</h4><p>处理 <code>.less</code> 样式文件，我们还需要另外安装 <a href="https://github.com/less/less.js">less</a> 和 <a href="https://github.com/webpack-contrib/less-loader">less-loader</a> 两个依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> less-loader依赖less，less-loader用于Webpack解析less样式文件，less用于解析less语法</span></span><br><span class="line">npm i -D less less-loader</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如同 css 一样，当 Webpack 构建打包时解析到 js 模块中有 <code>import</code> 后缀为 <code>.less</code> 的样式文件时，Webpack 会用 less-loader 去解析这个样式文件，并把样式文件代码转换为 css 语法，文件转为 css 样式文件，然后再搭配 css-loader 和 style-loader 做接下来的处理。</p>
</blockquote>
<p>安装完后，我们到 <code>webpack.common.js</code> 配置文件中，加入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123; ... &#125;,</span><br><span class="line">  ouput: &#123; ... &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: ISDEV, <span class="comment">// 开启后与devtool设置一致</span></span><br><span class="line">              importLoaders: <span class="number">1</span>, <span class="comment">// 需要先被less-loader处理，所以这里设置为1</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: ISDEV, <span class="comment">// 开启后与devtool设置一致</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ ... ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-SASS-样式文件"><a href="#3-SASS-样式文件" class="headerlink" title="3. SASS 样式文件"></a>3. SASS 样式文件</h4><p>处理 <code>.sass</code> 样式文件，我们还需要另外安装 <a href="https://github.com/sass/node-sass">node-sass</a> 和 <a href="https://github.com/webpack-contrib/sass-loader">sass-loader</a> 两个依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sass-loader依赖node-sass，sass-loader用于Webpack解析sass样式文件，sass用于解析sass语法</span></span><br><span class="line">npm i -D node-sass sass-loader</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如同 css 一样，当 Webpack 构建打包时解析到 js 模块中有 <code>import</code> 后缀为 <code>.sass</code> 的样式文件时，Webpack 会用 sass-loader 去解析这个样式文件，并把样式文件代码转换为 css 语法，文件转为 css 样式文件，然后再搭配 css-loader 和 style-loader 做接下来的处理。</p>
</blockquote>
<p>继续在 <code>webpack.common.js</code> 配置文件中，加入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123; ... &#125;,</span><br><span class="line">  ouput: &#123; ... &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: ISDEV, <span class="comment">// 开启后与devtool设置一致</span></span><br><span class="line">              importLoaders: <span class="number">1</span>, <span class="comment">// 需要先被less-loader处理，所以这里设置为1</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: ISDEV, <span class="comment">// 开启后与devtool设置一致</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ ... ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，通过上面的配置之后，我们再把 <code>src/app.css</code> 改为 <code>app.less</code> 或 <code>app.scss</code>，执行命令 <code>npm run start</code>，就会发现我们写的样式已经可以正常加载出来了。</p>
<h4 id="4-PostCSS-处理浏览器兼容问题"><a href="#4-PostCSS-处理浏览器兼容问题" class="headerlink" title="4. PostCSS 处理浏览器兼容问题"></a>4. PostCSS 处理浏览器兼容问题</h4><p>记得以前在写网页样式的时候，在涉及到 CSS3 的相关的样式语法时，都需要在前面加上浏览器的前缀做兼容性处理，当时就对 css 产生一种不好的印象，太麻烦了！而 PostCSS 就是来帮我们根据实际情况自动加上浏览器前缀的工具，大大减少了我们在编写样式时的顾虑。</p>
<blockquote>
<p>PostCSS 是 css 后处理器工具，因为有了 css，PostCSS 才能去处理他，所以叫后处理器<br>less/sass 是 css 预处理器工具，因为他们需要把 <code>.less</code> 和 <code>.scss</code> 处理成 <code>.css</code>，所以叫预处理器</p>
</blockquote>
<p>在这里我们主要用到以下几个 PostCSS 的插件依赖包：</p>
<ul>
<li><a href="https://github.com/luisrudge/postcss-flexbugs-fixes">postcss-flexbugs-fixes</a> 用于修复一些和 flex 布局相关的 bug</li>
<li><a href="https://github.com/csstools/postcss-preset-env">postcss-preset-env</a> 将最新的 css 语法转换为目标浏览器环境能够理解的 css 语法，目的是使开发者在编写样式代码时不用考虑浏览器的兼容性问题</li>
<li><a href="https://github.com/postcss/autoprefixer">autoprefixer</a> 用于自动添加浏览器前缀，处理样式语法兼容问题</li>
<li><a href="https://github.com/csstools/postcss-normalize">postcss-normalize</a> 从 browserslist 中自动导入所需要的 normalize.css 内容</li>
</ul>
<p>执行以下命令，安装相关依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D postcss postcss-loader postcss-flexbugs-fixes postcss-preset-env autoprefixer postcss-normalize</span><br></pre></td></tr></table></figure>

<p>安装完后，再到 <code>webpack.common.js</code> 配置文件中，把 <code>postcss-loader</code> 的配置放在刚刚上面置完的 <code>css</code> <code>less</code> <code>scss</code> 里的 <code>css-loader</code> 后面，配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  loader: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="comment">// 这里要注意配置是包裹在postcssOptions属性中</span></span><br><span class="line">    postcssOptions: &#123;</span><br><span class="line">      ident: <span class="string">&#x27;postcss&#x27;</span>,</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="comment">// 修复一些和flex布局相关的bug</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-flexbugs-fixes&#x27;</span>),</span><br><span class="line">        <span class="comment">// 参考browserslist的浏览器兼容表自动对那些还不支持的css语法做转换</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)(&#123;</span><br><span class="line">          <span class="comment">// 自动添加浏览器前缀</span></span><br><span class="line">          autoprefixer: &#123;</span><br><span class="line">            <span class="comment">// will add prefixes only for final and IE versions of specification</span></span><br><span class="line">            flexbox: <span class="string">&#x27;no-2009&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          stage: <span class="number">3</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">// 根据browserslist自动导入需要的normalize.css内容</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-normalize&#x27;</span>),</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 开启后与devtool设置一致</span></span><br><span class="line">    sourceMap: ISDEV,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果我们要为每一个之前所配置的样式 Loader 中都加一段这个代码的话，整个 <code>webpack.common.js</code> 配置文件会显得非常冗余，并且如果需要做修改的话，三个地方都得同步修改。所以我们可以把这里的公共部分的配置抽成一个函数，与 CRA 一致，命名为 <code>getCssLoaders</code>，因为新增了 <code>postcss-loader</code>，所以我们还需要修改 <code>css-loader</code> 的 <code>importLoaders</code> 参数的值，于是我们的 <code>webpack.common.js</code> 就变成如下这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getCssLoaders = <span class="function">(<span class="params">importLoaders</span>) =&gt;</span> [</span><br><span class="line">  <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: ISDEV, <span class="comment">// 开启后与devtool设置一致</span></span><br><span class="line">      importLoaders, <span class="comment">// 指定在css-loader处理前使用的laoder数量</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    loader: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">// 这里要注意配置是包裹在postcssOptions属性中</span></span><br><span class="line">      postcssOptions: &#123;</span><br><span class="line">        ident: <span class="string">&#x27;postcss&#x27;</span>,</span><br><span class="line">        plugins: [</span><br><span class="line">          <span class="comment">// 修复一些和flex布局相关的bug</span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&#x27;postcss-flexbugs-fixes&#x27;</span>),</span><br><span class="line">          <span class="comment">// 参考browserslist的浏览器兼容表自动对那些还不支持的css语法做转换</span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)(&#123;</span><br><span class="line">            <span class="comment">// 自动添加浏览器前缀</span></span><br><span class="line">            autoprefixer: &#123;</span><br><span class="line">              <span class="comment">// will add prefixes only for final and IE versions of specification</span></span><br><span class="line">              flexbox: <span class="string">&#x27;no-2009&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            stage: <span class="number">3</span>,</span><br><span class="line">          &#125;),</span><br><span class="line">          <span class="comment">// 根据browserslist自动导入需要的normalize.css内容</span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&#x27;postcss-normalize&#x27;</span>),</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 开启后与devtool设置一致</span></span><br><span class="line">      sourceMap: ISDEV,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123; ... &#125;,</span><br><span class="line">  output: &#123; ... &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: getCssLoaders(<span class="number">1</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          ...getCssLoaders(<span class="number">2</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: ISDEV,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          ...getCssLoaders(<span class="number">2</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: ISDEV,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ ... ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们还要回到 <code>package.json</code> 配置文件中添加 <code>browserslist</code> 属性（指定项目针对的目标浏览器范围）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span>: [<span class="string">&quot;&gt;0.2%&quot;</span>, <span class="string">&quot;not dead&quot;</span>, <span class="string">&quot;ie &gt;= 9&quot;</span>, <span class="string">&quot;not op_mini all&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果我们在入口文件 <code>app.js</code> 中，随便引入一个写了 <code>display: flex</code> 语法的样式文件，然后再执行命令 <code>npm start</code> 看看 PostCSS 是不是为我们自动加了浏览器前缀了？</p>
<h3 id="10-图片和字体文件处理"><a href="#10-图片和字体文件处理" class="headerlink" title="10. 图片和字体文件处理"></a>10. 图片和字体文件处理</h3><p>我们使用 file-loader 和 url-loader 来处理本地资源文件，比如：图片、字体文件等。而 url-loader 是对 file-loader 的封装，具有 file-loader 的所有功能，并且还提供了将低于阈值体积的图片装换成 base64 嵌入到页面中。但是，url-loader 并不依赖于 file-loader，所以一般我们只安装 url-loader 即可！</p>
<blockquote>
<p>我忽然想起以前面试官问过的一个问题：使用 base64 有什么好处？我就觉得把图片转为 base64 嵌入到页面中的好处就是不用二次请求，而坏处很明显就是转为 base64 后的体积会变大。所以对于大小较小的图片可以选择通过 url-loader 转为 base64 嵌入到页面中，较大的则就保持独立文件单独请求。</p>
</blockquote>
<p>执行以下命令，安装相关依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D url-loader</span><br></pre></td></tr></table></figure>

<p>安装完后，我们到 <code>webpack.common.js</code> 中继续在 <code>modules.rules</code> 中添加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123; ... &#125;,</span><br><span class="line">  ouput: &#123; ... &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: [<span class="regexp">/\.bmp$/</span>, <span class="regexp">/\.gif$/</span>, <span class="regexp">/\.jpe?g$/</span>, <span class="regexp">/\.png$/</span>],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 图片低于10k会被转换成base64格式的dataUrl</span></span><br><span class="line">              name: <span class="string">&#x27;[name].[contenthash:8].[ext]&#x27;</span>, <span class="comment">// [hash]占位符和[contenthash]是相同的含义，都是表示文件内容的摘要值，默认是使用md5 hash算法</span></span><br><span class="line">              outputPath: <span class="string">&#x27;assets/imgaes&#x27;</span>, <span class="comment">// 构建打包输出到出口文件夹的assets/images文件夹下</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(ttf|woff|woff2|eot|otf)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">&#x27;[name].[contenthash:8].[ext]&#x27;</span>,</span><br><span class="line">              outputPath: <span class="string">&#x27;assets/fonts&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"> plugins: [ ... ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单对以上配置做下解释：</p>
<ul>
<li><code>name</code> 属性的值表示输出的文件名为 <code>原来文件名.8位文件内容摘要.文件拓展名</code>，有了这个 8 位的文件内容摘要，可以防止图片更新后导致的缓存问题</li>
<li><code>limit</code> 属性的值表示，如果图片文件小于 <code>1024b</code>，即 <code>10kb</code>，那就使用 url-loader 把图片转为 base64 嵌入到网页中，否则就转而使用 file-loader 让图片保持独立文件</li>
<li><code>outputPath</code> 属性的值是以 <code>output.path</code> 的值为基准，既我们这里是以 <code>dist</code> 文件夹为基准，把图片或者字体文件通过构建打包流程后输出到 <code>dist/assets/images</code> 和 <code>dist/assets/fonts</code> 文件夹下</li>
</ul>
<p>接下来，可以随便把本地一张图片放入项目的 <code>src</code> 文件夹中，并创建一个文件 <code>demo.tsx</code> 然后在其中通过 <code>import</code> 引入该图片。</p>
<p>不幸的是会出现以下错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201130223738.png" alt="tsx引入图片错误"></p>
<p>可幸的是，可以通过在 <code>src</code> 下创建 TypeScript 类型定义文件 <code>typings/file.d.ts</code>，即可解决问题！其内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;*.svg&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> path: string;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;*.bmp&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> path: string;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;*.gif&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> path: string;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;*.jpg&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> path: string;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;*.jpeg&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> path: string;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;*.png&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> path: string;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经度过了重重难关，相信大家已经收获了不少新的知识。不过上面也只不过是 Webpack 的基本配置，目前我们的环境已经具备了 Webpack 的基本功能，接下下来我们还要让其达到完全支持 TypeScrtpt, React 以及关于开发构建环境和生产构建环境的优化，继续秉承着关关难过关关过的斗志向前进吧！</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201130230647.png" alt="加油"></p>
<h2 id="支持-React"><a href="#支持-React" class="headerlink" title="支持 React"></a>支持 React</h2><p>终于来到了关键的环节了，我们先通过以下命令安装 react 和 react-dom 依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> npm i -S是npm install --save的缩写</span></span><br><span class="line">npm i -S react react-dom</span><br></pre></td></tr></table></figure>

<p>其实当我们安装成功这两个依赖包后，就已经开始可以使用 jsx 语法了，我们在 <code>src</code> 文件夹下创建 <code>index.js</code> 代码文件，且内容改为如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./app&quot;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">&quot;#app&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>把 <code>src/app.js</code> 中的内容修改为以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app-content&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>然后再把 <code>webpack.common.js</code> 配置文件中 <code>entry</code> 属性里的入口文件修改为 <code>index.js</code>：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line"><span class="addition">+   app: path.resolve(PROJECT_PATH, &#x27;./src/index.js&#x27;),</span></span><br><span class="line"><span class="deletion">-   app: path.resolve(PROJECT_PATH, &#x27;./src/app.js&#x27;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这时候，如果你尝试执行命令 <code>npm start</code> 或 <code>npm run build</code> 的话，都会报错：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201130232621.png" alt="构建报错"></p>
<p>头上一万个问号，为什么呢？我们不是已经安装了 React 了吗？其实是因为 Webpack 根本不认识 jsx 语法，Webpack 需要 <a href="https://github.com/babel/babel-loader">babel-loader</a> 这位“翻译官”进行预处理。</p>
<p>既然已经提到了 Babel，那么我非常建议看到这里的你先阅读一篇关于 Babel 的文章：<a href="https://juejin.im/post/5ddff3abe51d4502d56bd143">不容错过的 Babel7 知识</a>，文章里为我们进行 Babel 的全方位介绍，看完再回来继续实践，我保证你一定会收获满满！虽然，我知道在认真阅读一篇文章时，再跳去阅读其他文章的方式很令人抗拒，但是由于该科普文章的确是会让我们对 Babel 的认识更上一层楼，所以强烈推荐！</p>
<p>到这里，我们应该执行以下命令安装有关 Babel 的依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D babel-loader @babel/core @babel/preset-react</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/babel/babel-loader">babel-loader</a> 使用 Babel 解析代码文件，<a href="https://babeljs.io/docs/en/next/babel-core.html">@babel/core</a> 是 Babel 的核心依赖，<a href="https://babeljs.io/docs/en/next/babel-preset-react">@babel/preset-react</a> 是转译 jsx 语法的预设集合（Babel 插件的预设集合）。</p>
<p>我们在项目根目录创建 <code>.babelrc</code> 配置文件，并输入以下代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-react&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://babeljs.io/docs/en/presets">presets</a> 是 Babel 的一些预设插件集合，比如 @babel/preset-react 一般会包含 @babel/plugin-syntax-jsx, @babel/plugin-transform-react-jsx, @babel/plugin-transform-react-display-name 这几个 Babel 插件。</p>
<p>接下来，我们到 <code>webpack.common.js</code> 配置文件，增加一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123; ... &#125;,</span><br><span class="line">  ouput: &#123; ... &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(tsx?|js)$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123; <span class="attr">cacheDirectory</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"> plugins: [ ... ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，我们匹配的代码文件后缀只有 <code>.ts</code> <code>.tsx</code> <code>.js</code>，把 <code>.jsx</code> 的后缀排除在外了。那是因为，我们不可能在 ts 环境下再使用 <code>.jsx</code> 代码文件来写代码了，实在要用 jsx 语法的时候，直接用 <code>.js</code> 不香吗？</p>
<p>babel-loader 在执行的时候，可能会产生一些运行时的公共文件，造成代码体积冗余，同时也会降低构建打包的效率，所以我们在 <code>options</code> 属性内配置了 Babel 的 <code>cacheDirectory: true</code> 参数，让 Babel 在运行时把这些公共文件缓存起来，下次编译的时候就会快很多。另外建议给 Loader 指定 <code>include</code> 或 <code>exclude</code>，指定其中一个即可，这样同样可以提升构建打包时的效率。</p>
<p>现在，我们可以通过执行命令 <code>npm start</code> 看看效果了！<strong>Babel 还有其他一些重要的配置，不过我们先把 TypeScript 给解决了再来继续回来倒腾 Babel。</strong></p>
<h2 id="支持-TypeScript"><a href="#支持-TypeScript" class="headerlink" title="支持 TypeScript"></a>支持 TypeScript</h2><p>Webpack 的模块系统只能识别 js 代码文件及其语法，遇到 jsx 语法、tsx 语法、图片、字体等文件就需要相应的 Loader 对其进行预处理，像图片、字体我们在上文中已经配置过了。为了支持 React，我们使用了 babel-loader 以及对应的 Babel 预设集合，如果现在要支持 TypeScript 我们也需要对应的 Babel 预设集合。</p>
<h3 id="1-安装对应-Babel-预设集合"><a href="#1-安装对应-Babel-预设集合" class="headerlink" title="1. 安装对应 Babel 预设集合"></a>1. 安装对应 Babel 预设集合</h3><p>@babel/preset-typescript 是 Babel 的一个 preset，他编译 TypeScript 时的过程比较粗暴，直接去掉其 ts 类型声明，然后再用其他 Babel 插件进行编译，所以他的速度很快。</p>
<p>废话少说，执行以下命令安装相关依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/preset-typescript</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：由于先前我们在配置 eslint 的时候，先安装了 TypeScript，所以这里就不用再安装了。</p>
</blockquote>
<p>然后到 <code>.babelrc</code> 配置文件，进行以下修改：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-react&quot;</span>, <span class="string">&quot;@babel/preset-typescript&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Babel 配置文件里的 presets 的执行顺序与 Webpack 配置文件里的 Loader 是一样的，都是从右往左，从下往上的执行，但 Babel 的 plugins 就与其相反。</p>
<h3 id="2-tsx-语法测试"><a href="#2-tsx-语法测试" class="headerlink" title="2. tsx 语法测试"></a>2. tsx 语法测试</h3><p>我们在 <code>src</code> 文件夹下创建一下两个 <code>.tsx</code> 文件，内容分别如下：</p>
<p><code>index.tsx</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./app&quot;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;aaron&quot;</span> <span class="attr">age</span>=<span class="string">&#123;18&#125;</span> /&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">&quot;#app&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props: IProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;app-content&quot;</span>&gt;</span><br><span class="line">      &lt;span&gt;&#123;<span class="string">`Hello my name is <span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;age&#125;</span> years old.`</span>&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>很简单的代码，在 <code>&lt;App /&gt;</code> 组件中传 props 时，因为有了 ts 所以有了良好的智能提示。比如不输入 <code>name</code> 或 <code>age</code>，那么就会报错，因为在 <code>&lt;App /&gt;</code> 组件中，这两个 prop 是必传的值。</p>
<p>但是，这个时候如果我们执行命令 <code>npm run start</code>，是会报错的。我们应该还得到 <code>webpack.common.js</code> 配置文件，做如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: path.resolve(PROJECT_PATH, <span class="string">&#x27;./src/index.tsx&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>], <span class="comment">// 经常被import的文件后缀放在前面</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下两点修改：</p>
<ol>
<li>修改了 <code>entry</code> 属性中的入口代码文件后缀，改为了 <code>.tsx</code></li>
<li>新增了 <code>resolve</code> 属性，并在 <code>resolve.extensions</code> 中定义好了文件后缀名，这样当我们在 import 某个代码文件的时候，就可以省略后缀名了</li>
</ol>
<blockquote>
<p>Webpack 会按照 <code>resolve.extensions</code> 中所定义的后缀名顺序依次查找代码文件，比如我们定义了 <code>[&#39;.tsx&#39;, &#39;.ts&#39;, &#39;.js&#39;, &#39;.json&#39;]</code>，那么 Webpack 会先把 <code>import</code> 的代码文件名尝试加上 <code>.tsx</code> 后缀在文件夹下查找，若找不到就会依次尝试查找。所以我们在配置时应该尽可能的把常用的后缀放在前面，这样可以缩短 Webpack 的查找时间，提升构建打包的效率</p>
</blockquote>
<p>这个时候，我们再执行命令 <code>npm start</code>，就能正常显示页面啦！</p>
<p>不过既然都用上了 TypeScript，那 React 的 ts 类型声明自然就不能少，执行以下命令安装相关依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @types/react @types/react-dom</span><br></pre></td></tr></table></figure>

<h3 id="3-tsconfig-json-详解"><a href="#3-tsconfig-json-详解" class="headerlink" title="3. tsconfig.json 详解"></a>3. tsconfig.json 详解</h3><p>每个 TypeScript 项目都需要有一个 <code>tsconfig.json</code> 配置文件，其作用简单的解释就是：</p>
<ul>
<li>编译指定的文件</li>
<li>定义了编译选项</li>
</ul>
<p>一般都会把 <code>tsconfig.json</code> 配置文件放在项目根目录下，我们执行以下命令来生成该配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx tsc --init</span><br></pre></td></tr></table></figure>

<p>打开生成的 <code>tsconfig.json</code> 配置文件，可以看到里面有很多注释和几个配置，有点乱。可以将内容替换为以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>, <span class="comment">// 编译成哪个版本的ES</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;ESNext&quot;</span>, <span class="comment">// 指定生成哪个模块系统的代码</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;dom&quot;</span>, <span class="string">&quot;dom.iterable&quot;</span>, <span class="string">&quot;esnext&quot;</span>], <span class="comment">// 编译过程中需要引入的库文件列表</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许编译js文件</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>, <span class="comment">// 在.tsx代码文件里支持jsx</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>, <span class="comment">// 指定模块解析策略</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 根路径</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Src/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;Components/*&quot;</span>: [<span class="string">&quot;src/components/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;Utils/*&quot;</span>: [<span class="string">&quot;src/utils/*&quot;</span>]</span><br><span class="line">    &#125;, <span class="comment">// 路径解析</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>, <span class="comment">// 支持CommonJS和ES模块之间的互操作性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用实验性的ES装饰器</span></span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>, <span class="comment">// 给源码里的装饰器声明加上设计类型元数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>, <span class="comment">// 忽略所有的声明文件（*.d.ts）的类型检查</span></span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span> <span class="comment">// 禁止对同一个文件的不一致的引用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span>: [<span class="string">&quot;node_modules&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍一下以上配置中的几个配置属性：</p>
<ul>
<li><p><code>complierOptions</code> 是用来配置 TypeScript 编译选项的，他的完整的可配置属性可以到 TypeScript 中文网<a href="https://www.tslang.cn/docs/handbook/compiler-options.html">编译选项章节</a>中查询到</p>
</li>
<li><p><code>type</code> 和 <code>module</code> 这两个属性其实在我们这里并没有什么用，他们要通过在命令行中执行 <code>tsc</code> 命令进行 ts 编译时才有用。但是实际上我们已经使用 Babel 去编译我们的 ts 语法了，根本不会使用 <code>tsc</code> 命令，所以他们在这里的作用就是让编译器提供错误提示</p>
</li>
<li><p><code>isolatedModules</code> 可以提供额外的一些语法检查</p>
<ul>
<li><p>比如不能重复 <code>export</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line">add();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; add &#125;; <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比如每个文件必须是独立的模块</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.ts</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function">(<span class="params">content: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(content);</span><br><span class="line">&#125;; <span class="comment">// 会报错，没有模块导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="keyword">export</span> print = <span class="function">(<span class="params">content: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(content)</span><br><span class="line">&#125; <span class="comment">// 必须要有export</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>esModuleInterop</code> 允许我们导入符合 es6 模块规范的 CommonJS 模块，下面做简单演示：</p>
<p>比如某个包 <code>test</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_moduls/test/index.js</span></span><br><span class="line"><span class="built_in">exports</span> = test;</span><br></pre></td></tr></table></figure>

<p>在我们项目中的 <code>app.tsx</code> 代码文件中使用此包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> test <span class="keyword">from</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>开启 <code>esModuleInterop</code> 后，我们可以直接以下面这种方式使用此包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>strict</code> 属性的值我们这里设置为 true ，就表示启用所有严格类型检查选项，既然上了 TypeScript 的船，就用最严格的类型检查，拒绝 AnyScript</p>
</li>
<li><p><code>exclude</code> 指定了不需要编译的文件，我们这里设置了只要是 <code>node_modules</code> 下的代码文件，我们都不进行编译。当然，也可以使用 <code>include</code> 去指定需要编译的代码文件，一般两个之中用一个就可以了</p>
</li>
</ul>
<p>接下来我们单独的讲一下 <code>baseUrl</code> 和 <code>paths</code> 这两个配置属性，这两配置属性可是提升开发效率的利器呀！他们的作用就是快速定位某个文件，防止在我们 <code>import</code> 时，出现多层 <code>../../../</code> 的这种写法。</p>
<p>比如现在我的 <code>src</code> 文件夹下有这么几个代码文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201021328.png" alt="文件目录"></p>
<p>我在 <code>app.tsx</code> 中要引入 <code>src/compoments</code> 下的 <code>Header</code> 组件的话，以往的方式应该为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&quot;./components/Header&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时可能大家都觉得，好像还可以，没啥毛病。但这是因为 <code>app.tsx</code> 和 <code>components</code> 是同级，试想一下如果在某个层级很深的文件里要用到 <code>components</code> 文件夹里的组件时，那 <code>import</code> 语句就是疯狂的 <code>../../../..</code> 了，所以我们要善用 <code>baseUrl</code> 和 <code>paths</code> 这两个配置属性，并结合 Webpack 配置文件里的 <code>resolve.alias</code> 搭配使用，这样才能提升写代码的幸福指数呀！</p>
<p>但是想用好他们，还是有点麻烦的，首先 <code>baseUrl</code> 属性的值一定要设置正确，我们的 <code>tsconfig.json</code> 配置文件是放在项目根目录的，那么 <code>baseUrl</code> 属性的值就应该设置为 <code>./</code> ，表示为项目的根目录。于是，<code>paths</code> 属性中的每一项路径映射，比如 <code>[&quot;src/*&quot;]</code> 其实就是相对于 <code>baseUrl</code> 属性的值来定位，也就是相对于项目根目录。</p>
<p>如果大家像上面一样进行了配置，并自己尝试以一下方式进行模块的引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&quot;Components/Header&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>就会发现报错了，并且是 eslint 报的错：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201022815.png" alt="eslint报错"></p>
<p>这个时候就需要修改 <code>.eslintrc.js</code> 配置文件了，首先我们先执行以下命令安装依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D eslint-import-resolver-typescript</span><br></pre></td></tr></table></figure>

<p>然后到 <code>.eslintrc.js</code> 配置文件的 <code>settings</code> 属性，进行以下修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  settings: &#123;</span><br><span class="line">    <span class="string">&#x27;import/resolver&#x27;</span>: &#123;</span><br><span class="line">      node: &#123;</span><br><span class="line">        <span class="comment">// 指定eslint-plugin-import解析的后缀名，出现频率高的文件类型放在前面</span></span><br><span class="line">        extensions: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 配合eslint-import-resolver-typescript解决ts的import时的路径映射问题</span></span><br><span class="line">      typescript: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，只需要在 <code>settings[&#39;import/resolver&#39;]</code> 中添加 <code>typescript: &#123;&#125;</code> 就可以了，这时候再回去看，是不是已经没有报错了！</p>
<p>但是上面的工作仅仅是解决编译器中 eslint 识别路径映射时的报错问题，我们还需要在 <code>webpack.common.js</code> 配置文件中的 <code>resolve.alias</code> 属性配置相同的映射规则，来解决 Webpack 在构建打包时的路径映射识别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    ...</span><br><span class="line">    alias: &#123;</span><br><span class="line">      Src: path.resolve(PROJECT_PATH, <span class="string">&#x27;./src&#x27;</span>),</span><br><span class="line">      Components: path.resolve(PROJECT_PATH, <span class="string">&#x27;./src/Components&#x27;</span>),</span><br><span class="line">      Utils: path.resolve(PROJECT_PATH, <span class="string">&#x27;./src/utils&#x27;</span>),</span><br><span class="line">    &#125;, <span class="comment">// 配置import时的路径映射</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，<code>tsconfig.json</code> 和 <code>webpack.common.js</code> 配置文件中关于路径映射的配置就保持一致了，那么就可以正常的进行开发啦！可能到这里，有的小伙伴会产生疑惑，我只配置 <code>webpack.common.js</code> 中的 <code>resolve.alias</code> 属性不就好了？虽然，开发的时候会有报错提示，但并不影响到代码的正确性，毕竟在开发构建打包和生产构建打包的过程中 Webpack 都会进行路径映射的替换。是的，的确是这样，但是在 <code>tsconfig.json</code> 中进行路径映射的配置，会给我们增加智能提示。比如我们在 <code>import</code> 输入路径时，我们输入到 <code>import Header form &#39;Com&#39;</code> 编辑器就会给我们提示补全正确的路径 <code>import Header from &#39;Components&#39;</code>，而且其文件夹下的文件还会继续提示。</p>
<p><strong>如果参与过较为庞大的项目，存在文件层级很深的情况时，就会明白编辑器的智能提示到底有多香了！</strong></p>
<h2 id="更多-Babel-配置"><a href="#更多-Babel-配置" class="headerlink" title="更多 Babel 配置"></a>更多 Babel 配置</h2><p>我们先前已经使用 Babel 去解析 React 和 TypeScript 的语法了，但是目前我们所做的也就如此而已。我们在项目中编写的 ES6+ 语法，在 Webpack 构建打包后还是会被原样输出，然而并不是所有的浏览器环境都支持 ES6+ 语法，这时候就需要 Babel 的 <a href="https://babeljs.io/docs/en/next/babel-preset-env.html">@babel/preset-env</a> 预设集合来帮我们做高级语法转译的这个苦力活了。他会根据设置的目标浏览器环境，也就是我们上面在 <code>package.json</code> 配置文件里设置过的 <code>browserslist</code> 属性里的配置信息，根据这个配置信息找出所需要的插件去转译 ES6+ 语法，比如 <code>const</code> 或 <code>let</code> 转译为 <code>var</code>。</p>
<p>但是，遇到 <code>Promise</code> 或者 <code>Array.prototype.map</code> 这类新的 api 时，是没有办法用直接转译来解决的。除非我们用低版本的代码实现此类新的 api ，然后再把实现的 api 代码注入到构建打包后的代码文件中填充所缺失的 api。虽然 @babel/preset-env 可以做这项工作，但是他在做这项工作时会直接在原生对象上挂载实现的代码，这样就会造成原生对象污染的问题发生。还好 Babel 还有一个宝藏插件 <a href="https://www.babeljs.cn/docs/babel-plugin-transform-runtime">@babel/plugin-transform-runtime</a> ，他和 @babel/preset-env 预设集合一样都能提供新 api 的垫片，都可以实现按需加载，但前者不会污染原型链。</p>
<p>另外，Babel 在编译每一个模块在需要的时候他会插入一些辅助函数，例如 <code>_extend</code>。每一个需要的模块都会插入这么一些辅助函数，这就很明显的造成了代码的冗余了，而 Babel 的 @babel/plugin-transform-runtime 插件会将所有的辅助函数都从 @babel/runtime 中导入（我们下面使用 @babel/runtime-corejs3），从而减少此类代码的冗余，可见这个插件的确是一个好同志！</p>
<p>执行以下代码，安装他们的依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/preset-env @babel/plugin-transform-runtime</span><br><span class="line">npm i -S @babel/runtime-corejs3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是 @babel/runtime-corejs3 为生成依赖包</p>
</blockquote>
<p>修改 <code>.babelrc</code> 配置文件，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;modules&quot;</span>: <span class="literal">false</span> <span class="comment">// 防止Babel将任何模块都转译成CommonJS类型，导致Webpack的tree-shaking失效</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;@babel/preset-react&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/preset-typescript&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="attr">&quot;proposals&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;useESModules&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截至目前，我们 TypeScript + React 的项目开发环境已经可以用于正常的项目开发了，但是如果想要得到更好的使用体验，我们还要针对开发构建环境和生产构建环境做优化，让我们继续往下看吧！</p>
<h2 id="Webpack-公共构建环境优化"><a href="#Webpack-公共构建环境优化" class="headerlink" title="Webpack 公共构建环境优化"></a>Webpack 公共构建环境优化</h2><p>小伙伴们能跟着我走到这一步，非常不容易！而这一部分所做的是无论开发构建环境还是生产构建环境中都需要做的公共配置优化工作。</p>
<h3 id="1-拷贝公共静态资源"><a href="#1-拷贝公共静态资源" class="headerlink" title="1. 拷贝公共静态资源"></a>1. 拷贝公共静态资源</h3><p>不知道大家有没有注意到，到目前为止，我们的开发页面还是没有自己的 icon，就是下图的这个东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201144831.png" alt="网页icon"></p>
<p>与 CRA 一样，我们将 <code>favicon.ico</code> 文件放到 <code>public</code> 文件夹下，我们可以复制 CRA 中 <code>favicon.ico</code> 文件，我已经为你们准备好了一个<a href="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20210218155414.ico">点击我</a>，然后在我们的 <code>index.html</code> 模板文件中加入以下标签：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line"><span class="addition">+   &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;images/x-icon&quot; /&gt;</span></span><br><span class="line">    &lt;title&gt;Webapck TypeScript React Practice&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候，如果我们执行命令 <code>npm run build</code>，可以看到 <code>dist</code> 文件夹下是没有 <code>favicon.ico</code> 文件的，那么 html 文件中的引入肯定也就没办法生效了。于是我们就希望有一个手段，能够在我们构建打包时把 <code>public</code> 文件夹下的静态资源通通都复制到我们出口文件夹 <code>dist</code> 中，反正我不会考虑手动去复制，所以我们还是使用 Webpack 的 <a href="https://github.com/webpack-contrib/copy-webpack-plugin">copy-webpack-plugin</a> 插件吧。</p>
<p>执行以下命令，安装他的依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D copy-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>安装完后，我们到 <code>webpack.common.js</code> 配置文件中，增加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          context: path.resolve(PROJECT_PATH, <span class="string">&#x27;./public&#x27;</span>),</span><br><span class="line">          <span class="keyword">from</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">          to: path.resolve(PROJECT_PATH, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">          toType: <span class="string">&#x27;dir&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们再次执行命令 <code>npm run build</code>，就会发现出口文件夹 <code>dist</code> 下就多了一个 <code>favicon.ico</code> 文件啦！然后也执行一下 <code>npm start</code>，不出意外浏览器也会显示出我们的小图标。同样地，其他的静态资源文件，大家只要往 <code>public</code> 文件夹下丢，Webpack 构建打包之后都会自动复制到 <code>dist</code> 出口文件夹下。</p>
<blockquote>
<p>特别注意，我们在 Webpack 基础配置时，在配置 html-webpack-plugin 时，配置信息中有一项 <code>cache: false</code>。如果不加这一项的话，那么修改代码之后刷新页面，html 模板文件不会引入任何打包出来的 js 代码文件，自然也就没有执行任何 js 代码。这个问题 copy-webpack-plugin 官方 issue 里有提到过。</p>
</blockquote>
<h3 id="2-显示构建打包进度"><a href="#2-显示构建打包进度" class="headerlink" title="2. 显示构建打包进度"></a>2. 显示构建打包进度</h3><p>如果我们现在执行 <code>npm start</code> 和 <code>npm run build</code> 命令，控制台是没有任何信息能提示我们现在的进度到底怎么样。而一般来说构建打包的速度往往都需要一些时间，如果不是很熟悉项目的人，基本都会认为是不是卡住了，从而大大地提升了焦虑感。所以，显示进度是比较重要的，这是对开发者积极的正向反馈。</p>
<p>我们可以使用 <a href="https://github.com/nuxt/webpackbar">webpackbar</a> 来显示进度，执行以下命令来安装他的依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D webpackbar</span><br></pre></td></tr></table></figure>

<p>到 <code>webpack.common.js</code> 配置文件中，增加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> Webpackbar(&#123;</span><br><span class="line">      name: ISDEV ? <span class="string">&#x27;正在启动&#x27;</span> : <span class="string">&#x27;正在构建打包&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们再重新执行以下命令，就会发现有进度条提示了，特别令人安心。</p>
<h3 id="3-编译时的-TypeScript-类型检查"><a href="#3-编译时的-TypeScript-类型检查" class="headerlink" title="3. 编译时的 TypeScript 类型检查"></a>3. 编译时的 TypeScript 类型检查</h3><p>我们之前在配置 Babel 的时候提过，为了编译效率，Babel 在编译 TypeScript 时会直接将 ts 类型去掉，并不会对 ts 类型做检查。来看一个例子，来到我们之前创建的 <code>src/app.tsx</code> 文件，我故意解构出一个事先没有声明的属性 <code>wrong</code>，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201153600.png" alt="编辑器中ts类型检查报错"></p>
<p>可以看到，我尝试解构出的 <code>wrong</code> 是没有在 <code>interface IProps</code> 中声明的属性，在编辑器中肯定会被检测到并报错。但是，此时如果你执行命令 <code>npm start</code> 或 <code>npm run build</code> 的话，是可以正常的构建打包的。所以，可能在某一时刻某一个开发人员犯了这样的错误，但没有去处理这个问题，直到别人接手这个项目后，也不知道有这么一个问题，然后在执行构建打包命令时，就把这样的问题代码也一同给构建打包出来了！这样就完全丧失了 TypeScript 类型声明所带来的优势。</p>
<p>所以，我们需要借助 Webpack 的 fork-ts-checker-webpack-plugin 插件力量，他无论是在开发还是生产的构建打包时都会给我们进行 ts 类型的检查，并在检查到错误的时候给出准确的错误提示。</p>
<p>执行以下命令，安装相关依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D fork-ts-checker-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>安装完后，到 <code>webpack.common.js</code> 配置文件中，增加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> ForkTsCheckerWebpackPlugin(&#123;</span><br><span class="line">      typescript: &#123;</span><br><span class="line">        configFile: path.resolve(PROJECT_PATH, <span class="string">&#x27;./tsconfig.json&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们再执行 <code>npm start</code> 或 <code>npm run build</code> 命令时，就会在命令行中出现错误提示了，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201155216.png" alt="命令行中ts类型检查报错"></p>
<h3 id="4-加速二次构建打包速度"><a href="#4-加速二次构建打包速度" class="headerlink" title="4. 加速二次构建打包速度"></a>4. 加速二次构建打包速度</h3><p>我们这里所提到的”二次“指的是<strong>首次构建打包后的每一次</strong>。</p>
<p>有一个 Webpack 的神器插件就能大大滴提高二次构建打包的速度，他为程序中的模块（如：loadash）提供了一个中间缓存，并且把缓存放在了项目的 <code>node_modules/.cache/hard-source</code> 文件夹下，而这个神器插件就是 <code>hard-source-webpack-plugin</code>。在使用这个插件后，首次构建打包时可能耗时会比原来多一点，因为他要进行一些缓存工作，但在首次构建打包缓存后，之后的每次一构建打包都会变得快很多。</p>
<p>我们执行以下命令，来安装插件依赖包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D hard-source-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>安装好后，我们到 <code>webpack.common.js</code> 配置文件，增加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> HardSourceWebpackPlugin(),</span><br><span class="line">  ]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们执行两次 <code>npm start</code> 或 <code>npm run build</code> 命令，看看所花费的时间对比图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201161446.png" alt="构建打包时间对比图"></p>
<p>当然，随着项目的变大，这个时间差距会更加明显！</p>
<h3 id="5-externals-减少打包体积"><a href="#5-externals-减少打包体积" class="headerlink" title="5. externals 减少打包体积"></a>5. externals 减少打包体积</h3><p>到现在，我们无论是开发还是生产的构建打包，Webpack 都要先将 react, react-dom 等这些库代码打进我们最终的代码文件中。试想一下，当这种第三包变得越来越多的时候，最后构建打包出来的代码文件将会变得无比的大，用户在每次访问页面的时候，都需要下载一个那么大的文件，带来的就是首屏白屏时间变长，会严重影响用户体验。所以，我们将这种第三方依赖包剥离出构建打包的流程，采用 CDN 的形式引入。</p>
<p>到 <code>webpack.common.js</code> 配置文件中，增加一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  externals: &#123;</span><br><span class="line">    react: <span class="string">&#x27;React&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;react-dom&#x27;</span>: <span class="string">&#x27;ReactDOM&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码编写时，我们是这样使用 <code>react</code> 和 <code>react-dom</code> 的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>那么，我们已经在 <code>webpack.common.js</code> 配置文件中配置了 <code>externals</code> 属性，让 Webpack 把 <code>react</code> 和 <code>react-dom</code> 剥离出构建打包的流程了，所以最终构建打包出的代码文件中肯定也就没有这两个库的代码了。那肯定要有另外的方式将他们的代码引入到页面中，不然程序就没办法正常运行了。</p>
<p>于是我们打开 <code>public/index.html</code> 模板文件，用 <code>script</code> 标签引入这两个库：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;images/x-icon&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Webapck TypeScript React Practice&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"><span class="addition">+   &lt;script crossorigin src=&quot;https://unpkg.com/react@16.13.1/umd/react.production.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+   &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16.13.1/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>库的版本可以到 <code>package.json</code> 中进行确认</p>
</blockquote>
<p>然后，可以对比一下配置了 <code>externals</code> 属性前后的构建打包体积，会发现相差许多。</p>
<p>这个时候聪明的小伙伴就会疑惑了，我们好像无论配不配置 <code>externals</code>，最终需要下载的代码文件大小其实也是没有改变的呀。只不过一个是合在一个文件里一起下载，另一个是分开下载三个文件，大小都没有改变。其实并不是如此，这样做其实还有下面几个优势：</p>
<ul>
<li>http 缓存：当用户第一次下载后，之后每次进入页面，浏览器根据缓存策略，都不需要再次下载 <code>react</code> 和 <code>react-dom</code> 的代码文件</li>
<li>代码拆分：可以想象我们还没配置 <code>externals</code> 之前，<code>react</code> 和 <code>react-dom</code> 的代码最终都是会被 Webpack 与我们的业务代码一同构建打包到一起的，以至于我们业务代码哪怕做一丁点修改，那么构建打包时 <code>react</code> 与 <code>react-dom</code> 的代码也会一同再次参与打包。<strong>而且 <code>react</code> 和 <code>react-dom</code> 的代码一般都不会改变，除非我们手动升级</strong></li>
<li>Webpack 构建打包效率提升：由于不需要再构建打包 <code>react</code> 和 <code>react-dom</code> 的代码，所以 Webpack 的构建打包效率也会随之提升</li>
</ul>
<blockquote>
<p>其实还有另外两个方案也可以达到以上提到的这几个优势：</p>
<ol>
<li>Webapck Dll：这个方案对 Webpack 的配置会相对复杂一些，需要使用到两个 Webpack 的内置插件 DllPlugin 和 DllReferencePlugin，并且该方案的侧重使用场景是用于提升开发环境的构建速度的</li>
<li>配置 Webpack 的 <code>splitChunk</code> 属性：这个方案的话对 Webpakc 的配置就没有前一个那么复杂，但是该方案的侧重使用场景是把被多次引用的公共依赖单独拆分为一个独立的 chunk，以至于能够优化最后打包输出的 bundle 文件大小</li>
</ol>
<p>仔细看这几个方案其实都各有各的使用侧重场景，如果我们要使用的话，还得根据实际场景来选择使用。另外，这两个方案在后面可能会提到。如果大家对 Webpack Dll 和 externals 之间的差异感兴趣，可以阅读这篇文章：<a href="https://blog.csdn.net/neoveee/article/details/80577216">webpack dll VS external</a>。也可以可以查看这个问答了解 Webpack Dll 和 spilitChunks 的侧重使用场景：<a href="https://segmentfault.com/q/1010000009492666">webpack dllPlugin 是不是只用于开发环境？</a>。</p>
</blockquote>
<h3 id="6-抽离公共代码"><a href="#6-抽离公共代码" class="headerlink" title="6. 抽离公共代码"></a>6. 抽离公共代码</h3><h4 id="1-动态-import-例子"><a href="#1-动态-import-例子" class="headerlink" title="1. 动态 import 例子"></a>1. 动态 import 例子</h4><p>在讲抽离公共代码前，我们先讲一下 ES6 中的懒加载在 Webpack 中的实现。懒加载是优化单页面应用（SPA）首屏加载的利器，下面我们来演示一个例子，让大家明白有什么好处。</p>
<p>一般情况下，我们在代码中引入某个工具函数是这样写的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;./math.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>但是如果这样直接引入的话，在 Webapck 打包之后 <code>math.js</code> 这个文件中的代码就会直接被打进最终的代码文件里，即使 <code>add</code> 这个方法不一定在首屏时就使用。那么带来的坏处也显而易见，我既然都在首屏时不需要用到他，却还要承担下载这个目前还用不到且多余的代码，最终造成首屏的加载速度变慢。</p>
<p>但是，如果我们现在以下面这种方式进行引入的话：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./math.js&quot;</span>).then(<span class="function">(<span class="params">math</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Webpack 就会自动解析这个语法，然后进行代码分割，构建打包出来后，<code>math.js</code> 代码文件中的代码就会被自动打成一个独立的 bundle 文件，只有我们在页面进行交互时调用到了这个方法，页面才会去下载这个 bundle 文件，并执行方法。</p>
<h4 id="2-React-组件懒加载"><a href="#2-React-组件懒加载" class="headerlink" title="2. React 组件懒加载"></a>2. React 组件懒加载</h4><p>同样地，我们也可以对 React 组件进行这样的懒加载，我们使用 React 官方提供的懒加载方案的 <code>React.lazy</code> 方法和 <code>React.Suspense</code> 组件即可实现。下面做个简单演示：</p>
<p>我们到 <code>src/app.tsx</code> 代码文件，进行如下修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ComputedOne = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;Component/ComputedOne&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> ComputedTwo = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;Component/ComputedTwo&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showTwo, setShowTwo] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;app-content&quot;</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">        &lt;ComputedOne a=&#123;<span class="number">1</span>&#125; b=&#123;<span class="number">2</span>&#125; /&gt;</span><br><span class="line">        &#123;showTwo &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">ComputedTwo</span> <span class="attr">a</span>=<span class="string">&#123;3&#125;</span> <span class="attr">b</span>=<span class="string">&#123;4&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">        &lt;button <span class="keyword">type</span>=<span class="string">&quot;button&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> setShowTwo(!showTwo)&#125;&gt;</span><br><span class="line">          显示Two</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>创建 <code>src/components/ComputedOne/index.tsx</code> 代码文件，内容如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;Utils/math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComputedOne</span>(<span class="params">props: IProps</span>): <span class="title">JSX</span>.<span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; a, b &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> sum = add(a, b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;`Hi, I&#x27;m computed one, my sum is $&#123;sum&#125;.`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComputedOne;</span><br></pre></td></tr></table></figure>

<p>创建 <code>src/components/ComputedTwo/index.tsx</code> 代码文件，内容如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;Utils/math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComputedTwo</span>(<span class="params">props: IProps</span>): <span class="title">JSX</span>.<span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; a, b &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> sum = add(a, b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;`Hi, I&#x27;m computed one, my sum is $&#123;sum&#125;.`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComputedTwo;</span><br></pre></td></tr></table></figure>

<p>创建 <code>src/utils/math.ts</code> 代码文件，内容如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; add &#125;;</span><br></pre></td></tr></table></figure>

<p>接下来，我们执行命令 <code>npm run start</code> 并打开浏览器的控制台中的 Network 界面，会发现当我们点击”显示 Two“按钮时，页面会动态的去请求 <code>ComputedTwo</code> 组件的 bundle 文件并加载，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201182839.gif" alt="按需加载"></p>
<p>上面就是 React 组件懒加载的实现方式和效果展示，执行命令 <code>npm run build</code> 可以看到构建打包出以下文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201183213.png" alt="打包文件"></p>
<p>可以看到 Webapck 为我们的 <code>ComputedOne</code> 和 <code>ComputedTwo</code> 组件都分别构建打包出两个 bundle 文件 <code>1.9948ce68.js</code> 和 <code>2.9948ce68.js</code>，而这样带来的好处很明显：</p>
<ul>
<li>通过懒加载引入的组件，若该组件代码不变，构建打包出的 bundle 名也就不会改变。当文件部署到生产环境后，由于浏览器的缓存策略，用户不需要再次下载该 bundle 文件，提高页面性能，降低服务器压力</li>
<li>可以防止把所有代码都打进主 bundle 里，降低主 bundle 的体积，减少页面首屏加载时间</li>
</ul>
<h4 id="3-配置-Webpack-的-splitChunks"><a href="#3-配置-Webpack-的-splitChunks" class="headerlink" title="3. 配置 Webpack 的 splitChunks"></a>3. 配置 Webpack 的 splitChunks</h4><p>从上文看来懒加载所带来的优势不容小觑，我们试着沿着这个思维向外延伸思考，如果我们能把一些引用的第三方依赖包也构建打包成单独的 bundle，是不是也会有类似的优势呢？</p>
<p>答案是肯定的，因为一般第三方依赖包只要版本锁定，代码就不会有太大的变化，就如我们刚刚配置 <code>externals</code> 时的两个库 <code>react</code> 和 <code>react-dom</code> 也是如此。那么我们每一次进行项目代码迭代时，都不会影响到第三方依赖包 bundle 文件的文件名，那么也就具有以上优势。</p>
<p>其实 webpack4 默认就有这个功能并且还默认开启了，但是我们要将第三方依赖包也打出独立的 bundle 的话，就需要到 <code>webpack.common.js</code> 配置文件中增加一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      name: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们临时来科普一下 Webpack 概念性的知识，在 Webpack 中主要有三个概念：</p>
<ol>
<li><p>module：就是 js 模块化，Webpack 支持 CommonJS、ES6 等模块化规范，简单来说就是我们通过 <code>import</code> 引入的代码文件</p>
</li>
<li><p>chunk：chunk 是 webpack 根据功能拆分出来的东西，主要包含三种情况：Webpack 配置中的项目入口、通过 <code>import()</code> 动态引入的代码、通过 <code>spilitChunks</code> 拆分出来的代码。chunk 包含着 module ，他们可能是一对一也可能是一对多的关系</p>
</li>
<li><p>bundle：bundle 是 Webpack 打包后的各个文件，一般与 chunk 是一对一的关系，bundle 就是 chunk 经过 Webpack 编译压缩打包处理之后的产出物</p>
</li>
</ol>
</blockquote>
<p>这个时候，我们执行命令 <code>npm run build</code>，就会发现又多了一个前缀名为 <code>vendors</code> 的 bundle 文件，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201190404.png" alt="打包文件"></p>
<p>这个 bundle 文件里放了一些我们没有通过配置 <code>externals</code> 剔除的第三方依赖包代码，<strong>如果大家不想通过 CDN 形式引入 <code>react</code> 和 <code>react-dom</code> 的话，也可以不配置 <code>externals</code> 转而配置 <code>splitChunks</code> 将他们单独抽离出来。</strong>另外，如果项目构建的是多页面应用，还需要加以配置 <code>splitChunks</code> 属性把公共模块也抽离出来，不过我们是搭建单页面应用开发环境，所以在这里就不演示了。</p>
<blockquote>
<p>如果大家对 <code>splitChunks</code> 的配置感兴趣可以阅读这篇文章：<a href="https://www.cnblogs.com/kwzm/p/10314438.html">理解 webpack4.splitChunks</a></p>
</blockquote>
<h2 id="Webpack-开发构建环境优化"><a href="#Webpack-开发构建环境优化" class="headerlink" title="Webpack 开发构建环境优化"></a>Webpack 开发构建环境优化</h2><p>这部分主要是针对开发构建环境使用体验的优化</p>
<h3 id="1-热更新"><a href="#1-热更新" class="headerlink" title="1. 热更新"></a>1. 热更新</h3><p>如果开发时忍受过稍微改一下代码，就要自己手动刷新页面，又或者稍微改一下代码，页面就自动重新刷新的痛苦，那么热更新一定得学会了！可能小项目会觉得没什么大不了，但是大项目里每一次修改刷新都是痛呀。</p>
<p>所谓热更新，其实就是页面只会对我们改动过的地方进行“局部更新”，不过这个说法可能也不太严谨，但是我们不用太抠细节，反正就是这么个意思。</p>
<p>而我们只要两个步骤就能开启热更新了，首先到 <code>webpack.dev.js</code> 配置文件中进行以下配置：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+const webpack = require(&#x27;webpack&#x27;);</span></span><br><span class="line">const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;);</span><br><span class="line">const common = require(&#x27;./webpack.common&#x27;);</span><br><span class="line">const &#123; SERVER_HOST, SERVER_PORT &#125; = require(&#x27;../constants&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  devtool: &#x27;cheap-module-eval&#x27;,</span><br><span class="line"><span class="addition">+ plugins: [new webpack.HotModuleReplacementPlugin()],</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: SERVER_HOST, // 指定host，不设置的话默认为localhost</span><br><span class="line">    port: SERVER_PORT, // 指定端口，不设置的话默认为8080</span><br><span class="line">    stats: &#x27;errors-only&#x27;, // 重点仅打印error</span><br><span class="line">    compress: true, // 是否启用gzip压缩</span><br><span class="line">    open: true, // 打开默认浏览器</span><br><span class="line"><span class="addition">+   hot: true, // 热更新</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候，我们执行命令 <code>npm start</code> 并尝试修改组件代码，保存后发现整个页面还是会刷新。如果我们希望达到上面所说的“局部更新”，还需要在项目入口文件 <code>src/index.tsx</code> 中进行以下修改：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import App from &quot;./app&quot;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+if (module &amp;&amp; module.hot) &#123;</span></span><br><span class="line"><span class="addition">+ module.hot.accept();</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.querySelector(&quot;#app&quot;));</span><br></pre></td></tr></table></figure>

<p>这时因为 ts 的原因，编辑器上会有报错提示，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201194541.png" alt="ts报错提示"></p>
<p>此时，我们只需要安装 @types/webpack-env 依赖包即可解决这个问题，执行以下命令安装依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @types/webpack-env</span><br></pre></td></tr></table></figure>

<p>现在，我们重新执行命令 <code>npm start</code>，再随便改个组件的代码看看，是不是不会整个页面刷新了？赞！此时，如果你修改了某个组件引入的样式的话就会发现有同样的效果，这是因为 Webpack 的 style-loader 实现了 Webpack HMR 的接口，所以当我们修改样式代码时，style-loader 就会收到 HRM 的修改通知，然后 style-loader 就会把处理好的样式代码交给 HMR，然后 HMR 就把代码更新到页面上。</p>
<h3 id="2-React-保留状态热更新"><a href="#2-React-保留状态热更新" class="headerlink" title="2. React 保留状态热更新"></a>2. React 保留状态热更新</h3><p>我们在上一小节成功的配置了热更新，并且我们还知道了修改样式代码也会有局部热更新的效果的原因是因为 style-loader 实现了 Webpack HMR 的接口。如果仔细的小伙伴就会发现，我们目前的热更新是没办法保留住 React 组件状态的，也就是说当我们在页面组件的某一个状态进行组件代码修改的话，那么热更新将会把当前组件的状态丢失，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201223618.gif" alt="热更新React组件状态丢失"></p>
<p>在我们点击“显示 Two”后，<code>ComputedTwo</code> 组件就显示出来了，随后我们又修改了 <code>ComputedTwo</code> 组件的代码，然后就触发了热更新同时页面的组件状态也丢失了。</p>
<p>不过小伙伴们也不用太慌张，因为有一个 Webpack 的 Loader 能解决这个问题，而他就是 <a href="https://github.com/gaearon/react-hot-loader">react-hot-loader</a>，但他并不是通过什么魔法手段来实现这个功能，只是他同样的也实现了上述的 Webpack HMR 接口，以至于他能够跟 style-loader 一样有类似的能力。</p>
<p>废话少说，就让我们执行以下命令，安装插件依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -S react-hot-loader</span><br><span class="line">npm i -D @hot-loader/react-dom</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意，react-hot-loader 要以生产依赖包的形式来安装，不用担心的是他在生产环境下不会被执行并且他会确保自己以最小的体积呈现。而 @hot-loader/react-dom 官方文档说是用来替换默认的 react-dom 来添加额外的热更新特性，用以支持 react hooks 热更新用的。</p>
</blockquote>
<p>我们到 <code>.babelrc</code> 配置文件中添加 react-hot-loader 在 Babel 中的插件，如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+   &quot;react-hot-loader/babel&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到 <code>webpack.common.js</code> 配置文件中的 <code>entry</code> 属性里的入口前加入 react-hot-loader 的热更新补丁，如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line"><span class="addition">+   app: [&#x27;react-hot-loader/patch&#x27;, path.resolve(PROJECT_PATH, &#x27;./src/index.tsx&#x27;)],</span></span><br><span class="line"><span class="deletion">-   app: path.resolve(PROJECT_PATH, &#x27;./src/index.tsx&#x27;),</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到 <code>webpack.dev.js</code> 配置文件中添加 <code>resolve</code> 属性，并在其内配置 <code>alias[react-dom] = &#39;@hot-loader/react-dom&#39;</code> 使 @hot-loader/react-dom 在开发构建环境时代替 react-dom，如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="addition">+ resolve: &#123;</span></span><br><span class="line"><span class="addition">+   alias: &#123;</span></span><br><span class="line"><span class="addition">+     &#x27;react-dom&#x27;: &#x27;@hot-loader/react-dom&#x27;,</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line"><span class="addition">+ &#125;,</span></span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>到 <code>src/index.tsx</code> 代码文件中添加 react-hot-loader 接管根组件代码，<strong>hot 函数就是一个 hoc</strong> 嘛，如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"><span class="addition">+import &#123; hot &#125; from &#x27;react-hot-loader/root&#x27;;</span></span><br><span class="line">import App from &#x27;./app&#x27;;</span><br><span class="line"></span><br><span class="line">if (module &amp;&amp; module.hot) &#123;</span><br><span class="line">  module.hot.accept();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ReactDOM.render(hot(&lt;App /&gt;), document.querySelector(&#x27;#app&#x27;));</span></span><br><span class="line"><span class="deletion">-ReactDOM.render(&lt;App /&gt;, document.querySelector(&#x27;#app&#x27;));</span></span><br></pre></td></tr></table></figure>

<p>好啦！我们现在可以再次执行命令 <code>npm start</code> 并重复上面验证热更新丢失状态的动作，会发现现在热更新已经不会丢失我们的 React 组件状态了，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201201231609.gif" alt="热更新保留React组件状态"></p>
<p>大功告成！</p>
<h3 id="3-后端接口代理"><a href="#3-后端接口代理" class="headerlink" title="3. 后端接口代理"></a>3. 后端接口代理</h3><p>有时候我们在做开发时，可能所使用的后端接口并不受自己控制也不支持跨域请求，这时候就很苦逼的需要花时间来搭建一个接口代理。不过巧的是 webpack-dev-server 刚好提供了这个功能，而我们可以在 <code>webpack.dev.js</code> 配置文件中的 <code>devServer.proxy</code> 属性里配置接口代理实现跨域请求。但是，为了使构建环境的代码与业务代码分离，我们需要将配置文件独立出来。</p>
<p>在 <code>src</code> 文件夹下新建一个 <code>setApiProxy.js</code>，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxySettings = &#123;</span><br><span class="line">  <span class="string">&quot;/api/&quot;</span>: &#123;</span><br><span class="line">    target: <span class="string">&quot;http://192.168.1.1:8080&quot;</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;/api2/&quot;</span>: &#123;</span><br><span class="line">    target: <span class="string">&quot;http://182.168.1.2:8080&quot;</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">&quot;^/api2&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = proxySettings;</span><br></pre></td></tr></table></figure>

<p>配置完成后，我们在 <code>webpack.dev.js</code> 配置文件中引入，并配置 <code>devServer.proxy</code> 属性，修改如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const proxySetting = require(&#x27;../../src/setApiProxy&#x27;);</span></span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  ...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+   proxy: &#123; ...proxySetting &#125;, // 配置接口代理</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就配置完成啦！大家可以自行测试一下是否可以正常使用。</p>
<h2 id="Webpack-生产构建环境优化"><a href="#Webpack-生产构建环境优化" class="headerlink" title="Webpack 生产构建环境优化"></a>Webpack 生产构建环境优化</h2><p>这部分主要是针对生活构建环境使用体验的优化</p>
<h3 id="1-CSS-拆分"><a href="#1-CSS-拆分" class="headerlink" title="1. CSS 拆分"></a>1. CSS 拆分</h3><p>其实不瞒大家，现在我们所写的所有样式在 Webpack 的构建打包后都会存在于 js bundle 文件中。如果就这样放任下去，随时样式代码的增多，打包出来的 js bundle 文件就会越来越大，从而影响我们页面的性能。所以从 js bundle 中拆分出 css 势在必行！我们可以使用 Webpack 的 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin">mini-css-extract-plugin</a> 来执行这项任务。</p>
<p>执行以下命令，安装插件依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure>

<p>安装完成后，在 <code>webpack.common.js</code> 配置文件中，增加和修改以下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);</span></span><br><span class="line"></span><br><span class="line">const getCssLoaders = (importLoaders) =&gt; [</span><br><span class="line"><span class="addition">+  ISDEV ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader,</span></span><br><span class="line"><span class="deletion">- &#x27;style-loader&#x27;</span></span><br><span class="line">  ...</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+   !ISDEV &amp;&amp;</span></span><br><span class="line"><span class="addition">+     new MiniCssExtractPlugin(&#123;</span></span><br><span class="line"><span class="addition">+       filename: &#x27;css/[name].[contenthash:8].css&#x27;,</span></span><br><span class="line"><span class="addition">+       chunkFilename: &#x27;css/[name].[contenthash:8].css&#x27;,</span></span><br><span class="line"><span class="addition">+     &#125;), // 判断生产环境下才使用mini-css-exract-plugin</span></span><br><span class="line"><span class="addition">+ ].filter(Boolean),</span></span><br><span class="line"><span class="deletion">- ],</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<strong>mini-css-extract-plugin 需要搭配他自己所提供的 Loader 一起使用，并且该 Loader 与 style-loader 互斥</strong>，但是只有 style-loader 实现了 Webpack HMR 的热更新接口，另外开发环境中对于拆分 CSS 的也没有特别大的需求，所以我们就<strong>需要判断只在生产环境中使用 mini-css-extract-plugin</strong>。</p>
</blockquote>
<p>此时，我们随便写点样式，然后执行命令 <code>npm run build</code>，就能发现 <code>dist</code> 目录下多了样式文件，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201202030814.png" alt="样式文件"></p>
<h3 id="2-去除无用样式代码"><a href="#2-去除无用样式代码" class="headerlink" title="2. 去除无用样式代码"></a>2. 去除无用样式代码</h3><p>如果我们现在在写样式时，写了一些没有用到的样式代码时，Webpack 在构建打包时也会一起把这些没有用到的样式代码一起打进产出的 bundle 中，这显然是可以优化的地方呀。所以，这下又要用上另一个 Webpack 的神器插件 <a href="https://github.com/FullHuman/purgecss/tree/master/packages/purgecss-webpack-plugin">purgecss-webpack-plugin</a>，不过使用他时还需要依赖一个路径查找利器 <a href="https://github.com/isaacs/node-glob">node-glob</a>。</p>
<p>执行以下命令，安装相关依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D purgecss-webpack-plugin glob</span><br></pre></td></tr></table></figure>

<p>安装完后，在 <code>webpack.prod.js</code> 中，增加以下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const path = require(&#x27;path&#x27;);</span></span><br><span class="line"><span class="addition">+const glob = require(&#x27;glob&#x27;);</span></span><br><span class="line"><span class="addition">+const PurgecssWebpackPlugin = require(&#x27;purgecss-webpack-plugin&#x27;);</span></span><br><span class="line"><span class="addition">+const &#123; PROJECT_PATH &#125; = require(&#x27;../constants&#x27;);</span></span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+   new PurgecssWebpackPlugin(&#123;</span></span><br><span class="line"><span class="addition">+     paths: glob.sync(`$&#123;path.resolve(PROJECT_PATH, &#x27;./src&#x27;)&#125;/**/*.&#123;tsx,less,scss,css&#125;`, +&#123; nodir: true &#125;),</span></span><br><span class="line"><span class="addition">+   &#125;),</span></span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>简单解释一下上面的配置，<code>glob</code> 是用来查找文件路径的，我们使用 <code>glob.sync()</code> 方法以同步的方式找到 <code>src</code> 文件夹下后缀为 <code>.tsx</code> <code>.less</code> <code>.scss</code> <code>.css</code> 的文件路径并且以数组的形式赋值给 <code>paths</code> 属性。然后 purgecss-webpack-plugin 就会解析每一个路径对应的文件，将无用的样式去除，而 <code>nodir</code> 属性就是去除文件夹的路径，加快处理的速度。为了直观给大家看下 <code>glob</code> 获取的路径数组，打印出来长这个样子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&quot;H:/Projects/Front/webpack-typescript-react-practice2/src/app.scss&quot;</span>,</span><br><span class="line">  <span class="string">&quot;H:/Projects/Front/webpack-typescript-react-practice2/src/app.tsx&quot;</span>,</span><br><span class="line">  <span class="string">&quot;H:/Projects/Front/webpack-typescript-react-practice2/src/components/ComputedOne/index.tsx&quot;</span>,</span><br><span class="line">  <span class="string">&quot;H:/Projects/Front/webpack-typescript-react-practice2/src/components/ComputedTwo/index.less&quot;</span>,</span><br><span class="line">  <span class="string">&quot;H:/Projects/Front/webpack-typescript-react-practice2/src/components/ComputedTwo/index.tsx&quot;</span>,</span><br><span class="line">  <span class="string">&quot;H:/Projects/Front/webpack-typescript-react-practice2/src/demo.tsx&quot;</span>,</span><br><span class="line">  <span class="string">&quot;H:/Projects/Front/webpack-typescript-react-practice2/src/index.tsx&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要注意，一定要把引入样式的 <code>.tsx</code> 组件文件后缀配置到 <code>glob.sync()</code> 方法的参数中，不然 purgecss-webpack-plugin 没办法解析到底哪个样式有给是用到，自然也就无法正确的剔除没有用到的样式代码了。</p>
</blockquote>
<p>此时，可以写一些没有被用到的样式代码，然后执行命令 <code>npm run build</code> ，看一下是不是没有了多余的代码！</p>
<h3 id="3-代码压缩"><a href="#3-代码压缩" class="headerlink" title="3. 代码压缩"></a>3. 代码压缩</h3><p>在生产构建打包环境中，压缩代码时必须要做的工作，毕竟这样做能够把产出的 bundle 文件体积减少一大半，何乐而不为？</p>
<h4 id="1-JavaScript-代码压缩"><a href="#1-JavaScript-代码压缩" class="headerlink" title="1. JavaScript 代码压缩"></a>1. JavaScript 代码压缩</h4><p>Webpack 4 中的 js 代码压缩神器 <a href="https://github.com/webpack-contrib/terser-webpack-plugin">terser-webpack-plugin</a> 插件应该是无人不知了把？虽然网上很多教程都还在讲 Webpack 压缩代码的时候要使用 <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin">uglifyjs-webpack-plugin</a>，但是他早就被放弃维护了，而且他还不支持 ES6 语法，Webpack 的核心开发者 <a href="https://github.com/evilebottnawi">evilebottnawi</a> 也都已经转向维护 terser-webpack-plugin 了。</p>
<p>虽然，在 Webpack 中 <code>mode</code> 为 <code>production</code> 时默认开启，没错！Webpack 4 完全内置 terser-webpack-plugin，不过为了能够对他进行一些额外配置，我们还是得安装他。</p>
<p>执行以下命令，安装插件依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于我们使用的是Webpack 4，所以插件版本也要对应上</span></span><br><span class="line">npm i -D terser-webpack-plugin@4</span><br></pre></td></tr></table></figure>

<p>安装完后，到 <code>webpack.common.js</code> 文件中的 <code>optimization</code> 属性中，增加做增加以下配置：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const TerserWebpackPlugin = require(&#x27;terser-webpack-plugin&#x27;);</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line"><span class="addition">+   minimize: !ISDEV,</span></span><br><span class="line"><span class="addition">+   minimizer: [</span></span><br><span class="line"><span class="addition">+     !ISDEV &amp;&amp;</span></span><br><span class="line"><span class="addition">+       new TerserWebpackPlugin(&#123;</span></span><br><span class="line"><span class="addition">+         extractComments: false,</span></span><br><span class="line"><span class="addition">+         terserOptions: &#123;</span></span><br><span class="line"><span class="addition">+           compress: &#123; pure_funcs: [&#x27;console.log&#x27;] &#125;,</span></span><br><span class="line"><span class="addition">+         &#125;,</span></span><br><span class="line"><span class="addition">+       &#125;),</span></span><br><span class="line"><span class="addition">+   ].filter(Boolean),</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先，我们在配置中增加了 <code>minimize</code> 属性，可以设置开启或关闭压缩。如果我们设置为 <code>true</code>，Webpack 就会默认使用 terser-webpack-plugin，反之就表示不压缩代码。接下来的 <code>minimizer</code> 属性就是用来指定压缩器的。</p>
<p>然后再简单介绍一下我们在 terser-webpack-plugin 中所做的配置：</p>
<ul>
<li><code>extractComments</code> 设置为 <code>fasle</code> 意味着去除所有注释，除了带有特殊标记的注释，例如 <code>@preserve</code> 标识，后面我们用的一个插件就会用到这个标识</li>
<li><code>pure_funcs</code> 可以设置我们想要去除的函数，我们这里就设置把代码中的 <code>console.log</code> 函数给去除掉</li>
</ul>
<h4 id="2-CSS-代码压缩"><a href="#2-CSS-代码压缩" class="headerlink" title="2. CSS 代码压缩"></a>2. CSS 代码压缩</h4><p>同样也是耳熟能详的 Webpack 插件 optimize-css-assets-webpack-plugin，执行命令直接安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>然后同样到 <code>webpack.common.js</code> 配置文件的 <code>minimizer</code> 属性新增以下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const OptimizeCssAssetsWebpackPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;);</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: !ISDEV,</span><br><span class="line">    minimizer: [</span><br><span class="line">      ...</span><br><span class="line"><span class="addition">+     !ISDEV &amp;&amp; new OptimizeCssAssetsWebpackPlugin(),</span></span><br><span class="line">    ].filter(Boolean),</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-添加版权声明"><a href="#4-添加版权声明" class="headerlink" title="4. 添加版权声明"></a>4. 添加版权声明</h3><p>上面我们在配置 JavaScript 代码压缩的小章节中说过，打包时 terser-webpack-plugin 会把除含有特殊标识的其他所有注释都去除，而所谓的特殊标识就例如 <code>@preserve</code> 这种。我们希望自己的代码里可以有一些声明注释，就像 React 的包中就有类似的这些声明注释，我们可以使用 Webpack 内置的 BannerPlugin 插件来实现。</p>
<p>无需安装依赖包，直接到 <code>webpack.prod.js</code> 配置文件中，加入以下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const webpack = require(&#x27;webpack&#x27;);</span></span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  ...+</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+   new webpack.BannerPlugin(&#123;</span></span><br><span class="line"><span class="addition">+     raw: true,</span></span><br><span class="line"><span class="addition">+     banner:</span></span><br><span class="line"><span class="addition">+       &#x27;/** @preserve Powered by webpack-typescript-react-practice2 (https://github.com/aaronlam/webpack-typescript-react-practice2) */&#x27;,</span></span><br><span class="line"><span class="addition">+   &#125;),</span></span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这时候，执行命令 <code>npm run build</code> 构建打包，再看下输出的 bundle 代码文件，是不是就有注释啦！</p>
<h3 id="5-tree-shaking"><a href="#5-tree-shaking" class="headerlink" title="5. tree-shaking"></a>5. tree-shaking</h3><p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting@master/20201202153915.gif" alt="摇树"></p>
<p>tree-shaking 的意思，通过上图应该就可以说明其意思了。而我们这里所说的 tree-shaking 可以理解为通过工具“摇”我们的 JS 代码文件，将其中用不到的代码“摇”下来。具体来说，Webpack 入口文件就相当于一棵树的主干，入口文件有很多依赖的模块相当于树枝，实际代码中可能依赖了某个模块，但是只使用了其中的某些功能，通过 Webpack 内置的 tree-shaking 就能把这些没有使用的代码摇掉，来到达删除无用代码的目的。而当 <code>mode</code> 属性的值为 <code>production</code> 时，也就是生产构建环境下，<strong>Webpack 会根据 ES6 的模块语</strong>法执行这项摇树任务。</p>
<p>举个例子，我们在 <code>src/utils/math.ts</code> 代码文件中，做以下修改：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+function minus(a: number, b: number): number &#123;</span></span><br><span class="line"><span class="addition">+  return a - b;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+export &#123; add, minus &#125;;</span></span><br><span class="line"><span class="deletion">-export &#123; add &#125;;</span></span><br></pre></td></tr></table></figure>

<p>回到我们的 <code>src/components/ComputedOne/index.tsx</code> 组件代码文件中，做以下修改：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+import &#123; add, minus &#125; from &#x27;Utils/math&#x27;;</span></span><br><span class="line"><span class="deletion">-import &#123; add &#125; from &#x27;Utils/math&#x27;;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在组件代码文件中同时引入了 <code>add</code> 和 <code>minus</code> 两个方法，但是实际上只使用了 <code>add</code> 方法，这时我们执行命令 <code>npm run build</code>，可以搜索一下 <code>ComputedOne</code> 组件的 bundle 文件中，是没办法找到关于 <code>minus</code> 的代码的，但是却能搜到关于 <code>add</code> 的代码，这就意味着 <code>minus</code> 因为没有被使用，而被 Webpack 通过 tree-shaking 去除了。</p>
<p>另外在我们开发项目的时候，如果能确保项目中所写的模块没有副作用，那么可以在 <code>package.json</code> 配置文件中设置 <code>sideEffects: false</code> 属性，那么当别人引用我们项目的时候 Webpack 就能够毫不留情的进行 tree-shaking。关于 <code>sideEffects</code> 属性的说明可以阅读 Webapck 官方文档的 <a href="https://webpack.js.org/guides/tree-shaking/">Tree Shaking 章节</a>。</p>
<p>然后我们可以尝试回忆一下，先前在配置 <code>.babelrc</code> 配置文件的 @babel/preset-env 预设集合时，在其参数部分配置了 <code>modules: false</code>，目的就是让 Babel 不要把我们所写的 ES 模块转换成 CommonJS 模块。因为只有 ES 模块才能进行 tree-shaking，其原因主要是以下几个：</p>
<ol>
<li><code>import</code> 导入语句只能在模块顶层作用域中使用</li>
<li><code>import</code> 的模块名只能是字符串常量</li>
<li><code>import</code> 的 binding 为 immutable</li>
<li>ES 模块作用域中默认是严格模式，不会产生副作用</li>
</ol>
<p>有了以上几个特点后，ES 模块就支持静态分析，以至于能够进行 tree-shaking 操作。</p>
<h3 id="6-bundle-分析"><a href="#6-bundle-分析" class="headerlink" title="6. bundle 分析"></a>6. bundle 分析</h3><p>有时候，我们想知道我们项目所构建打包的依赖包都有哪些、体积有多大、打包后的 bundle 是否合理，根据这些信息来进行进一步的项目优化。而这时我们就可以使用 Webpack 的 webpack-bundle-analyzer 插件来达前面提到的想法。</p>
<p>执行以下命令，安装其依赖包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>

<p>到 <code>scripts\constants.js</code> 文件，增加一下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const ISANALYZE = process.env.npm_config_report === &#x27;true&#x27;;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ..</span><br><span class="line"><span class="addition">+ ISANALYZE,</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到 <code>webpack.prod.js</code> 配置文件，增加以下代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="addition">+const &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;);</span></span><br><span class="line"><span class="addition">+const &#123; PROJECT_PATH, ISANALYZE &#125; = require(&#x27;../constants&#x27;);</span></span><br><span class="line"><span class="deletion">-const &#123; PROJECT_PATH &#125; = require(&#x27;../constants&#x27;);</span></span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+   ISANALYZE &amp;&amp;</span></span><br><span class="line"><span class="addition">+     new BundleAnalyzerPlugin(&#123;</span></span><br><span class="line"><span class="addition">+       analyzerMode: &#x27;server&#x27;, // 开启一个本地服务查看分析报告</span></span><br><span class="line"><span class="addition">+       analyzerHost: &#x27;127.0.0.1&#x27;, // 指定本地服务的host</span></span><br><span class="line"><span class="addition">+       analyzerPort: 2000, // 指定本地服务的端口</span></span><br><span class="line"><span class="addition">+     &#125;),</span></span><br><span class="line"><span class="addition">+ ].filter(Boolean),</span></span><br><span class="line"><span class="deletion">- ],</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后再回到 <code>package.json</code> 配置文件中的 <code>scripts</code> 属性中添加以下代配置信息：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line"><span class="addition">+   &quot;build-analyzer&quot;: &quot;cross-env NODE_ENV=production npm_config_report=true webpack --config ./scripts/config/webpack.prod.js&quot;,</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们执行命令 <code>npm run build-analyzer</code> 就会自动打开浏览器并显示 bundle 分析页面，尽情享用吧！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此我们的路途也就结束了。虽然我知道估计应该没几个人会看到这里，不过还是想用记录来帮助自己加深学习。</p>
<p>其实我觉得整个搭建流程走下来还是挺流畅的，真正的做到了从 0 到 1 搭建属于自己的一个开发环境，当然也可以说是脚手架。在整篇文章中我都希望能够把每一个章节的细节都阐述清楚，把为什么要这么做的历史原因讲述给大家听，以至于在编写整篇文章时大部分时间都花在了查阅资料上。</p>
<p>我知道可能对于一些刚接触前端工程化的小伙伴来说可能会带来很大的压力，这是很正常的一件事，因为我刚开始接触时也是这样，而且当时还找不到比较体系化的资料来学习。不过我觉得如果能咬咬牙坚持看完做完，尽管第一遍下来可能很多地方都可能似懂非懂，但是我能保证一定能够帮助你构建一个宏观的概念，然后可以把这篇当做一本字典来使用。更重要的是我希望大家都能够从实践中领悟到探索精神，可怕不代表不可能，实践才能出真知！</p>
<p>这篇文章中的很多配置其实并非都是强耦合的，比如 TypeScript + React 就可以替换成 TypeScript + Vue，也可能有一些插件可以替换成更优秀的，这个就需要根据大家的实际情况去做调整了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>React</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
</search>
